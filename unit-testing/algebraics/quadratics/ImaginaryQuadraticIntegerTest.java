/*
 * Copyright (C) 2018 Alonso del Arte
 *
 * This program is free software: you can redistribute it and/or modify it under 
 * the terms of the GNU General Public License as published by the Free Software 
 * Foundation, either version 3 of the License, or (at your option) any later 
 * version.
 *
 * This program is distributed in the hope that it will be useful, but WITHOUT 
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS 
 * FOR A PARTICULAR PURPOSE. See the GNU General Public License for more 
 * details.
 *
 * You should have received a copy of the GNU General Public License along with 
 * this program. If not, see <http://www.gnu.org/licenses/>.
 */
package algebraics.quadratics;

import algebraics.AlgebraicDegreeOverflowException;
import algebraics.NotDivisibleException;
import algebraics.UnsupportedNumberDomainException;
import calculators.NumberTheoreticFunctionsCalculator;
import static viewers.ImagQuadRingDisplay.MINIMUM_RING_D;
import java.text.DecimalFormatSymbols;

//import java.text.DecimalFormatSymbols;
import java.util.List;
import java.util.ArrayList;
import java.util.Random;
import org.junit.BeforeClass;
import org.junit.Ignore;
import org.junit.Test;
import static org.junit.Assert.*;

/**
 * Tests for the ImaginaryQuadraticInteger class, which defines objects that 
 * represent imaginary quadratic integers.
 * @author Alonso del Arte, from template generated by NetBeans IDE
 */
public class ImaginaryQuadraticIntegerTest {
    
    /**
     * The ring of Gaussian integers, <b>Z</b>[<i>i</i>], numbers of the form 
     * <i>a</i> + <i>bi</i>. This is one of the rings in which 
     * ImaginaryQuadraticInteger will be tested.
     */
    private static final ImaginaryQuadraticRing RING_GAUSSIAN = new ImaginaryQuadraticRing(-1);
    
    /**
     * The ring <b>Z</b>[&radic;-2], numbers of the form  <i>a</i> + 
     * <i>b</i>&radic;-2. This is one of the rings in which 
     * ImaginaryQuadraticInteger will be tested.
     */
    private static final ImaginaryQuadraticRing RING_ZI2 = new ImaginaryQuadraticRing(-2);
    
    /**
     * The ring of Eisenstein integers, <b>Z</b>[&omega;], numbers of the form 
     * <i>a</i> + <i>b</i>&omega;, where &omega; = -1/2 + (&radic;-3)/2. This is 
     * one of the rings in which ImaginaryQuadraticInteger will be tested.
     */
    private static final ImaginaryQuadraticRing RING_EISENSTEIN = new ImaginaryQuadraticRing(-3);
    
    /**
     * The ring <i>O</i><sub><b>Q</b>(&radic;-7)</sub>, numbers of the form 
     * <i>a</i>/2 + (<i>b</i>&radic;-7)/2, where <i>a</i> and <i>b</i> are of 
     * the same parity (both odd or both even). This is one of the rings in 
     * which ImaginaryQuadraticInteger will be tested.
     */
    private static final ImaginaryQuadraticRing RING_OQI7 = new ImaginaryQuadraticRing(-7);
    
    /**
     * A ring that will be randomly chosen during setUpClass().
     */
    private static ImaginaryQuadraticRing ringRandom;
    
    /**
     * A ring <i>O</i><sub><b>Q</b>(&radic;<i>d</i>)</sub> specifically for 
     * testing {@link ImaginaryQuadraticInteger#toStringAlt()}, 
     * {@link ImaginaryQuadraticInteger#toASCIIStringAlt()}, 
     * {@link ImaginaryQuadraticInteger#toTeXStringAlt()} and 
     * {@link ImaginaryQuadraticInteger#toHTMLStringAlt}. This will be the same 
     * as ringRandom if the parameter <i>d</i> of that one is of the form 
     * 4<i>k</i> + 1. Otherwise, its parameter <i>d</i> will be the next higher 
     * squarefree number of the form 4<i>k</i> + 1.
     */
    private static ImaginaryQuadraticRing ringRandomForAltTesting;
    
    private static List<QuadraticInteger> testIntegers, testAdditiveInverses, testConjugates, testNorms;
    private static List<Integer> testNormsRealParts;
    
    /**
     * The value of 0 as an ImaginaryQuadraticInteger. Which 
     * ImaginaryQuadraticRing this zero is in will depend on the needs of the 
     * tests.
     */
    private static ImaginaryQuadraticInteger zeroIQI;
    
    private static int randomRealPart, randomImagPart, randomRealForHalfInts, randomImagForHalfInts, totalTestIntegers;
    
    /**
     * The imaginary unit, <i>i</i> = &radic;&minus;1.  This duplicates a field 
     * in {@link NumberTheoreticFunctionsCalculator}. This repetition is 
     * necessary to make these tests independent of that class.
     */
    private static final ImaginaryQuadraticInteger IMAG_UNIT_I = new ImaginaryQuadraticInteger(0, 1, RING_GAUSSIAN);
    
    /**
     * The other imaginary unit, &minus;<i>i</i> = &minus;&radic;&minus;1. This 
     * duplicates a field in {@link NumberTheoreticFunctionsCalculator}. This 
     * repetition is necessary to make these tests independent of that class. In
     * particular, this one in that other class is defined as {@link 
     * NumberTheoreticFunctionsCalculator#IMAG_UNIT_I}.times(-1), which can 
     * cause a cascade of misleading test failures here if one is working on 
     * {@link ImaginaryQuadraticInteger#times(int)}.
     */
    private static final ImaginaryQuadraticInteger IMAG_UNIT_NEG_I = new ImaginaryQuadraticInteger(0, -1, RING_GAUSSIAN);
    
    /**
     * A complex cubic root of unity, &minus;1/2 + &radic;&minus;3/2.  This 
     * duplicates a field in {@link NumberTheoreticFunctionsCalculator}. This 
     * repetition is necessary to make these tests independent of that class.
     */
    private static final ImaginaryQuadraticInteger COMPLEX_CUBIC_ROOT_OF_UNITY = new ImaginaryQuadraticInteger(-1, 1, RING_EISENSTEIN, 2);
    
    /**
     * Sets up the static variables that will be used for the tests. Some of the 
     * values are pseudorandom numbers within given bounds.
     */
    @BeforeClass
    public static void setUpClass() {
        int randomDiscr = -NumberTheoreticFunctionsCalculator.randomSquarefreeNumber(MINIMUM_RING_D);
        if (randomDiscr > -5) {
            randomDiscr = -5; // This is just in case we get -3 or -1, which we are already testing for and which require special treatment in some of the tests.
        }
        boolean ringRandomd1mod4 = (randomDiscr % 4 == -3);
        ringRandom = new ImaginaryQuadraticRing(randomDiscr);
        if (ringRandom.hasHalfIntegers()) {
            ringRandomForAltTesting = ringRandom;
        } else {
            int nextD = ringRandom.getRadicand();
            do {
                nextD++;
            } while (!(NumberTheoreticFunctionsCalculator.isSquareFree(nextD) && (nextD % 4 == -3)));
            ringRandomForAltTesting = new ImaginaryQuadraticRing(nextD);
            System.out.println(ringRandomForAltTesting.toASCIIString() + " has been chosen for testing toStringAlt(), toASCIIStringAlt, toTeXStringAlt and toHTMLStringAlt.");
        }
        System.out.println(ringRandom.toASCIIString() + " has been randomly chosen for testing purposes.");
        int maxAB = (int) Math.floor(Math.sqrt(Integer.MAX_VALUE/((-4) * (randomDiscr + 1))));
        System.out.println("Maximum for real and imaginary parts is " + maxAB);
        Random ranNumGen = new Random();
        randomRealPart = ranNumGen.nextInt(2 * maxAB) - maxAB;
        randomImagPart = ranNumGen.nextInt(2 * maxAB) - maxAB;
        if (randomImagPart == 0) {
            randomImagPart = 1; // We want to make sure none of these random imaginary quadratic integers are purely real.
        }
        randomRealForHalfInts = 2 * randomRealPart + 1;
        randomImagForHalfInts = 2 * randomImagPart + 1;
        zeroIQI = new ImaginaryQuadraticInteger(0, 0, RING_GAUSSIAN);
        testIntegers = new ArrayList<>();
        testAdditiveInverses = new ArrayList<>();
        testConjugates = new ArrayList<>();
        testNorms = new ArrayList<>();
        testNormsRealParts = new ArrayList<>();
        int currNorm;
        ImaginaryQuadraticInteger currIQI = new ImaginaryQuadraticInteger(randomRealPart, randomImagPart, RING_GAUSSIAN);
        testIntegers.add(currIQI);
        currIQI = new ImaginaryQuadraticInteger(-randomRealPart, -randomImagPart, RING_GAUSSIAN);
        testAdditiveInverses.add(currIQI);
        currIQI = new ImaginaryQuadraticInteger(randomRealPart, -randomImagPart, RING_GAUSSIAN);
        testConjugates.add(currIQI);
        currNorm = randomRealPart * randomRealPart + randomImagPart * randomImagPart;
        currIQI = new ImaginaryQuadraticInteger(currNorm, 0, RING_GAUSSIAN, 1);
        testNorms.add(currIQI);
        testNormsRealParts.add(currNorm);
        currIQI = new ImaginaryQuadraticInteger(randomRealPart, randomImagPart, RING_ZI2);
        testIntegers.add(currIQI);
        currIQI = new ImaginaryQuadraticInteger(-randomRealPart, -randomImagPart, RING_ZI2);
        testAdditiveInverses.add(currIQI);
        currIQI = new ImaginaryQuadraticInteger(randomRealPart, -randomImagPart, RING_ZI2);
        testConjugates.add(currIQI);
        currNorm = randomRealPart * randomRealPart + 2 * randomImagPart * randomImagPart;
        currIQI = new ImaginaryQuadraticInteger(currNorm, 0, RING_ZI2);
        testNorms.add(currIQI);
        testNormsRealParts.add(currNorm);
        currIQI = new ImaginaryQuadraticInteger(randomRealForHalfInts, randomImagForHalfInts, RING_EISENSTEIN, 2);
        testIntegers.add(currIQI);
        currIQI = new ImaginaryQuadraticInteger(-randomRealForHalfInts, -randomImagForHalfInts, RING_EISENSTEIN, 2);
        testAdditiveInverses.add(currIQI);
        currIQI = new ImaginaryQuadraticInteger(randomRealForHalfInts, -randomImagForHalfInts, RING_EISENSTEIN, 2);
        testConjugates.add(currIQI);
        currNorm = (randomRealForHalfInts * randomRealForHalfInts + 3 * randomImagForHalfInts * randomImagForHalfInts)/4;
        currIQI = new ImaginaryQuadraticInteger(currNorm, 0, RING_EISENSTEIN);
        testNorms.add(currIQI);
        testNormsRealParts.add(currNorm);
        currIQI = new ImaginaryQuadraticInteger(randomRealForHalfInts, randomImagForHalfInts, RING_OQI7, 2);
        testIntegers.add(currIQI);
        currIQI = new ImaginaryQuadraticInteger(-randomRealForHalfInts, -randomImagForHalfInts, RING_OQI7, 2);
        testAdditiveInverses.add(currIQI);
        currIQI = new ImaginaryQuadraticInteger(randomRealForHalfInts, -randomImagForHalfInts, RING_OQI7, 2);
        testConjugates.add(currIQI);
        currNorm = (randomRealForHalfInts * randomRealForHalfInts + 7 * randomImagForHalfInts * randomImagForHalfInts)/4;
        currIQI = new ImaginaryQuadraticInteger(currNorm, 0, RING_OQI7, 1);
        testNorms.add(currIQI);
        testNormsRealParts.add(currNorm);
        if (ringRandomd1mod4) {
            currIQI = new ImaginaryQuadraticInteger(randomRealForHalfInts, randomImagForHalfInts, ringRandom, 2);
            testIntegers.add(currIQI);
            currIQI = new ImaginaryQuadraticInteger(-randomRealForHalfInts, -randomImagForHalfInts, ringRandom, 2);
            testAdditiveInverses.add(currIQI);
            currIQI = new ImaginaryQuadraticInteger(randomRealForHalfInts, -randomImagForHalfInts, ringRandom, 2);
            testConjugates.add(currIQI);
            currNorm = (randomRealForHalfInts * randomRealForHalfInts + (-randomDiscr) * randomImagForHalfInts * randomImagForHalfInts)/4;
            currIQI = new ImaginaryQuadraticInteger(currNorm, 0, ringRandom);
            testNorms.add(currIQI);
            testNormsRealParts.add(currNorm);
        } else {
            currIQI = new ImaginaryQuadraticInteger(randomRealPart, randomImagPart, ringRandom);
            testIntegers.add(currIQI);
            currIQI = new ImaginaryQuadraticInteger(-randomRealPart, -randomImagPart, ringRandom);
            testAdditiveInverses.add(currIQI);
            currIQI = new ImaginaryQuadraticInteger(randomRealPart, -randomImagPart, ringRandom);
            testConjugates.add(currIQI);
            currNorm = randomRealPart * randomRealPart + (-randomDiscr) * randomImagPart * randomImagPart;
            currIQI = new ImaginaryQuadraticInteger(currNorm, 0, ringRandom);
            testNorms.add(currIQI);
            testNormsRealParts.add(currNorm);
        }
        totalTestIntegers = testIntegers.size();
    }
    
    /**
     * Test of algebraicDegree method, of class ImaginaryQuadraticInteger.
     */
    @Test
    public void testAlgebraicDegree() {
        System.out.println("algebraicDegree");
        int expResult = 2; // Quadratic integers with nonzero imaginary part should have algebraic degree 2
        int result;
        for (int i = 0; i < totalTestIntegers; i++) {
            result = testIntegers.get(i).algebraicDegree();
            assertEquals(expResult, result);
            result = testAdditiveInverses.get(i).algebraicDegree();
            assertEquals(expResult, result);
            result = testConjugates.get(i).algebraicDegree();
            assertEquals(expResult, result);
        }
        expResult = 1; // Purely real nonzero integers should have algebraic degree 1
        for (QuadraticInteger normIQI : testNorms) {
            result = normIQI.algebraicDegree();
            assertEquals(expResult, result);
        }
        /* And last but not least, 0 should have algebraic degree 0 regardless 
           of which ring it comes from. */
        expResult = 0;
        result = zeroIQI.algebraicDegree();
        assertEquals(expResult, result);
        zeroIQI = new ImaginaryQuadraticInteger(0, 0, RING_EISENSTEIN);
        result = zeroIQI.algebraicDegree();
        assertEquals(expResult, result);
    }

    /**
     * Test of trace method, of class ImaginaryQuadraticInteger.
     */
    @Test
    public void testTrace() {
        System.out.println("trace");
        long expResult = 2 * randomRealPart;
        long result;
        for (int i = 0; i < totalTestIntegers; i++) {
            result = testIntegers.get(i).trace();
            if (testIntegers.get(i).getRing().hasHalfIntegers()) {
                assertEquals(randomRealForHalfInts, result);
            } else {
                assertEquals(expResult, result);
            }
        }
    }
    
    /**
     * Test of norm method, of class ImaginaryQuadraticInteger.
     */
    @Test
    public void testNorm() {
        System.out.println("norm");
        long expResult, result;
        for (int i = 0; i < totalTestIntegers; i++) {
            if (testIntegers.get(i).getRing().hasHalfIntegers()) {
                expResult = (randomRealForHalfInts * randomRealForHalfInts - testIntegers.get(i).getRing().getRadicand() * randomImagForHalfInts * randomImagForHalfInts)/4;
            } else {
                expResult = randomRealPart * randomRealPart - testIntegers.get(i).getRing().getRadicand() * randomImagPart * randomImagPart;
            }
            result = testIntegers.get(i).norm();
            assertEquals(expResult, result);
        }
    }

    /**
     * Test of minPolynomial method, of class ImaginaryQuadraticInteger.
     */
    @Test
    public void testMinPolynomial() {
        System.out.println("minPolynomial");
        long[] expResult = {0, 0, 1};
        long[] result;
        ImaginaryQuadraticInteger baseImagDist, purelyRealInt;
        for (int i = 0; i < totalTestIntegers; i++) {
            if (testIntegers.get(i).getRing().hasHalfIntegers()) {
                expResult[1] = -randomRealForHalfInts;
                expResult[0] = (randomRealForHalfInts * randomRealForHalfInts + randomImagForHalfInts * randomImagForHalfInts * testIntegers.get(i).getRing().getAbsNegRad())/4;
            } else {
                expResult[1] = (-2) * randomRealPart;
                expResult[0] = randomRealPart * randomRealPart + randomImagPart * randomImagPart * testIntegers.get(i).getRing().getAbsNegRad();
            }
            result = testIntegers.get(i).minPolynomial();
            assertArrayEquals(expResult, result);
            /* Now to test the mimimal polymomial of the purely imaginary 
               integer sqrt(d) */
            expResult[1] = 0;
            expResult[0] = testIntegers.get(i).getRing().getAbsNegRad();
            baseImagDist = new ImaginaryQuadraticInteger(0, 1, testIntegers.get(i).getRing());
            result = baseImagDist.minPolynomial();
            assertArrayEquals(expResult, result);
        }
        // Next, some purely real integers
        expResult[2] = 0;
        expResult[1] = 1;
        for (int i = 1; i < 10; i++) {
            expResult[0] = -i;
            purelyRealInt = new ImaginaryQuadraticInteger(i, 0, ringRandom);
            result = purelyRealInt.minPolynomial();
            assertArrayEquals(expResult, result);
        }
        // And last but not least, 0
        expResult[0] = 0;
        result = zeroIQI.minPolynomial();
        assertArrayEquals(expResult, result);
        zeroIQI = new ImaginaryQuadraticInteger(0, 0, ringRandom);
        result = zeroIQI.minPolynomial();
        assertArrayEquals(expResult, result);
    }

    /**
     * Test of minPolynomialString method, of class ImaginaryQuadraticInteger.
     * For methods that return Strings, spaces are desirable but not required.
     * Therefore the tests should strip out spaces before asserting equality. It
     * is understood that "0x" is implied in the minimal polynomial of purely 
     * imaginary integers and therefore "+0x" and "-0x" should both be excluded 
     * from the output.
     */
    @Test
    public void testMinPolynomialString() {
        System.out.println("minPolynomialString");
        String expResult, result;
        for (int i = 0; i < totalTestIntegers; i++) {
            expResult = "x^2";
            if (testIntegers.get(i).getRing().hasHalfIntegers()) {
                if (randomRealForHalfInts < 0) {
                    expResult = expResult + "+" + ((-1) * randomRealForHalfInts);
                } else {
                    expResult = expResult + "-" + randomRealForHalfInts;
                }
                expResult = expResult + "x+" + ((randomRealForHalfInts * randomRealForHalfInts + randomImagForHalfInts * randomImagForHalfInts * testIntegers.get(i).getRing().getAbsNegRad())/4);
            } else {
                if (randomRealPart < 0) {
                    expResult = expResult + "+" + ((-2) * randomRealPart);
                } else {
                    expResult = expResult + "-" + (2 * randomRealPart);
                }
                expResult = expResult + "x+" + (randomRealPart * randomRealPart + randomImagPart * randomImagPart * testIntegers.get(i).getRing().getAbsNegRad());
            }
            expResult = expResult.replace("+1x", "+x");
            expResult = expResult.replace("-1x", "-x");
            expResult = expResult.replace("+0x", "");
            expResult = expResult.replace("-0x", "");
            result = testIntegers.get(i).minPolynomialString().replace(" ", ""); // Strip out spaces
            assertEquals(expResult, result);
        }
        // Now to test the polynomial strings of a few purely real integers
        ImaginaryQuadraticInteger degreeOneInt;
        for (int j = 1; j < 8; j++) {
            degreeOneInt = new ImaginaryQuadraticInteger(j, 0, ringRandom);
            expResult = "x-" + j;
            result = degreeOneInt.minPolynomialString().replace(" ", "");
            assertEquals(expResult, result);
            degreeOneInt = new ImaginaryQuadraticInteger(-j, 0, ringRandom);
            expResult = "x+" + j;
            result = degreeOneInt.minPolynomialString().replace(" ", "");
            assertEquals(expResult, result);
        }
        /* I'm not terribly concerned about this one, so it's here more for the 
           sake of completeness than anything else. Feel free to delete if 
           inconvenient. */
        assertEquals("x", zeroIQI.minPolynomialString());
    }
    
    /**
     * Test of conjugate method, of class ImaginaryQuadraticInteger. These are 
     * the two main facts used to make sure conjugate() gives the right results: 
     * first, the norm of a quadratic integer divided by that quadratic integer 
     * is its conjugate; and second, the conjugate of a conjugate is the 
     * original quadratic integer.
     */
    @Test
    public void testConjugate() {
        System.out.println("conjugate");
        QuadraticInteger expResult, result;
        for (int i = 0; i < totalTestIntegers; i++) {
            try {
                expResult = testNorms.get(i).divides(testIntegers.get(i));
                result = testIntegers.get(i).conjugate();
                System.out.println("Conjugate of " + testIntegers.get(i).toASCIIString() + " is " + result.toASCIIString());
                assertEquals(expResult, result);
                assertEquals(testConjugates.get(i), result);
                result = result.conjugate();
                assertEquals(result, testIntegers.get(i));
            } catch (AlgebraicDegreeOverflowException adoe) {
                fail("AlgebraicDegreeOverflowException should not have occurred during test of conjugate().\n" + adoe.getMessage() + "\nThere may be a mistake in the setup of the test.");
            } catch (NotDivisibleException nde) {
                fail("NotDivisibleException should not have occurred during test of conjugate().\n" + nde.getMessage() + "\nThere may be a mistake in the setup of the test.");
            }
        }
    }
    
    /**
     * Test of abs, of class ImaginaryQuadraticInteger. Besides the algebraic 
     * integers from setUpClass(), this test also tests some purely real and 
     * purely imaginary Gaussian integers, and checks their real or imaginary 
     * parts against {@link Math#abs(double)}.
     */
    @Test
    public void testAbs() {
        System.out.println("abs");
        double xSquared = randomRealPart * randomRealPart;
        double preY = randomImagPart * randomImagPart;
        double ySquared, expResult, result;
        double xSqForHalfInts = randomRealForHalfInts * randomRealForHalfInts;
        double preYForHalfInts = randomImagForHalfInts * randomImagForHalfInts;
        ImaginaryQuadraticInteger ramifier;
        for (QuadraticInteger testInteger : testIntegers) {
            if (testInteger.getRing().hasHalfIntegers()) {
                ySquared = preYForHalfInts * testInteger.getRing().getAbsNegRad();
                expResult = (xSqForHalfInts + ySquared)/4;
                expResult = Math.sqrt(expResult);
            } else {
                ySquared = preY * testInteger.getRing().getAbsNegRad();
                expResult = Math.sqrt(xSquared + ySquared);
            }
            result = testInteger.abs();
            assertEquals(expResult, result, ImaginaryQuadraticRingTest.TEST_DELTA);
            // The result should be the same for the conjugate...
            result = testInteger.conjugate().abs();
            assertEquals(expResult, result, ImaginaryQuadraticRingTest.TEST_DELTA);
            // ...and the conjugate times -1...
            result = testInteger.conjugate().times(-1).abs();
            assertEquals(expResult, result, ImaginaryQuadraticRingTest.TEST_DELTA);
            // ...and the original number times -1.
            result = testInteger.conjugate().times(-1).abs();
            assertEquals(expResult, result, ImaginaryQuadraticRingTest.TEST_DELTA);
            // abs(sqrt(d)) should equal sqrt(-d)
            ramifier = new ImaginaryQuadraticInteger(0, 1, testInteger.getRing());
            expResult = testInteger.getRing().getAbsNegRadSqrt();
            result = ramifier.abs();
            assertEquals(expResult, result, ImaginaryQuadraticRingTest.TEST_DELTA);
        }
    }
    
    /**
     * Test of getRealPartNumeric method, of class ImaginaryQuadraticInteger.
     */
    @Test
    public void testGetRealPartMultNumeric() {
        System.out.println("getRealPartMultNumeric");
        double expResult = (double) randomRealForHalfInts/2;
        double result;
        for (int i = 0; i < totalTestIntegers; i++) {
            result = testIntegers.get(i).getRealPartNumeric();
            if (testIntegers.get(i).getRing().hasHalfIntegers()) {
                assertEquals(expResult, result, ImaginaryQuadraticRingTest.TEST_DELTA);
            } else {
                assertEquals(randomRealPart, result, ImaginaryQuadraticRingTest.TEST_DELTA);
            }
        }
    }

    /**
     * Test of getImagPartNumeric method, of class ImaginaryQuadraticInteger.
     */
    @Test
    public void testGetImagPartwRadMultNumeric() {
        System.out.println("getImagPartwRadMultNumeric");
        double expResult, result;
        for (int i = 0; i < totalTestIntegers; i++) {
            result = testIntegers.get(i).getImagPartNumeric();
            if (testIntegers.get(i).getRing().hasHalfIntegers()) {
                expResult = ((double) randomImagForHalfInts * testIntegers.get(i).getRing().getAbsNegRadSqrt())/2;
            } else {
                expResult = (double) randomImagPart * testIntegers.get(i).getRing().getAbsNegRadSqrt();
            }
            assertEquals(expResult, result, ImaginaryQuadraticRingTest.TEST_DELTA);
        }
    }

    /* (TEMPORARY JAVADOC DISABLE) *
     * Test of getTwiceRealPartMult method, of class ImaginaryQuadraticInteger.
     */
    // (AT)Test
//    public void testGetTwiceRealPartMult() {
//        System.out.println("getTwiceRealPartMult");
//        long expResult, result;
//        for (int i = 0; i < totalTestIntegers; i++) {
//            result = testIntegers.get(i).getTwiceRealPartMult();
//            if (testIntegers.get(i).getCausingRing().hasHalfIntegers()) {
//                expResult = randomRealForHalfInts;
//            } else {
//                expResult = 2 * randomRealPart;
//            }
//            assertEquals(expResult, result);
//        }
//    }

    /* (TEMPORARY JAVADOC DISABLE) *
     * Test of getTwiceImagPartMult method, of class ImaginaryQuadraticInteger.
     */
    //(AT)Test
//    public void testGetTwiceImagPartMult() {
//        System.out.println("getTwiceImagPartMult");
//        long expResult, result;
//        for (int i = 0; i < totalTestIntegers; i++) {
//            result = testIntegers.get(i).getTwiceImagPartMult();
//            if (testIntegers.get(i).getCausingRing().hasHalfIntegers()) {
//                expResult = randomImagForHalfInts;
//            } else {
//                expResult = 2 * randomImagPart;
//            }
//            assertEquals(expResult, result);
//        }
//    }
    
    /**
     * Test of getRegPartMult method, of class ImaginaryQuadraticInteger.
     */
    @Test
    public void testGetRegPartMult() {
        System.out.println("getRealPartMult");
        int expResult, result;
        for (int i = 0; i < totalTestIntegers; i++) {
            if (testIntegers.get(i).getRing().hasHalfIntegers()) {
                expResult = randomRealForHalfInts;
            } else {
                expResult = randomRealPart;
            }
            result = testIntegers.get(i).getRegPartMult();
            assertEquals(expResult, result);
        }
    }
    
    /**
     * Test of getSurdPartMult method, of class ImaginaryQuadraticInteger.
     */
    @Test
    public void testGetSurdPartMult() {
        System.out.println("getImagPartMult");
        int expResult, result;
        for (int i = 0; i < totalTestIntegers; i++) {
            if (testIntegers.get(i).getRing().hasHalfIntegers()) {
                expResult = randomImagForHalfInts;
            } else {
                expResult = randomImagPart;
            }
            result = testIntegers.get(i).getSurdPartMult();
            assertEquals(expResult, result);
        }
    }
    
    /**
     * Test of getCausingRing method, of class ImaginaryQuadraticInteger.
     */
    @Test
    public void testGetRing() {
        System.out.println("getRing");
        assertEquals(RING_GAUSSIAN, testIntegers.get(0).getRing());
        assertEquals(RING_ZI2, testIntegers.get(1).getRing());
        assertEquals(RING_EISENSTEIN, testIntegers.get(2).getRing());
        assertEquals(RING_OQI7, testIntegers.get(3).getRing());
        assertEquals(ringRandom, testIntegers.get(4).getRing());
    }
    
    /**
     * Test of getDenominator method, of class ImaginaryQuadraticInteger. This 
     * tests depends on the test integers determined by setUpClass() which come 
     * from rings with "half-integers" to themselves be "half-integers."
     */
    @Test
    public void testGetDenominator() {
        System.out.println("getDenominator");
        for (int i = 0; i < totalTestIntegers; i++) {
            if (testIntegers.get(i).getRing().hasHalfIntegers()) {
                assertEquals(2, testIntegers.get(i).getDenominator());
            } else {
                assertEquals(1, testIntegers.get(i).getDenominator());
            }
        }
    }
    
    /**
     * Test of toString method, of class ImaginaryQuadraticInteger. For methods 
     * that return Strings, spaces are desirable but not required. Therefore the 
     * tests should strip out spaces before asserting equality.
     */
    @Test
    public void testToString() {
        System.out.println("toString");
        String expResult;
        if (randomRealPart == 0) {
            expResult = randomImagPart + "i";
        } else {
            expResult = randomRealPart + "+" + randomImagPart + "i";
        }
        expResult = expResult.replace("+-", "-");
        expResult = expResult.replace("+1i", "+i");
        expResult = expResult.replace("-1i", "-i");
        String result = testIntegers.get(0).toString().replace(" ", "");
        assertEquals(expResult, result);
        for (int i = 1; i < totalTestIntegers; i++) {
            if (testIntegers.get(i).getRing().hasHalfIntegers()) {
                expResult = randomRealForHalfInts + "/2+" + randomImagForHalfInts + "\u221A(" + testIntegers.get(i).getRing().getRadicand() + ")/2";
            } else {
                if (randomRealPart == 0) {
                    expResult = randomImagPart + "\u221A(" + testIntegers.get(i).getRing().getRadicand() + ")";
                } else {
                    expResult = randomRealPart + "+" + randomImagPart + "\u221A(" + testIntegers.get(i).getRing().getRadicand() + ")";
                }
            }
            expResult = expResult.replace("+-", "-");
            expResult = expResult.replace("+1\u221A", "+\u221A");
            expResult = expResult.replace("-1\u221A", "-\u221A");
            result = testIntegers.get(i).toString().replace(" ", "");
            assertEquals(expResult, result);
        }
        // Lastly to test on a couple of complex units
        expResult = "i";
        result = IMAG_UNIT_I.toString();
        assertEquals(expResult, result);
        expResult = "-i";
        result = IMAG_UNIT_NEG_I.toString();
        assertEquals(expResult, result);
        expResult = "-1/2+\u221A(-3)/2";
        result = COMPLEX_CUBIC_ROOT_OF_UNITY.toString().replace(" ", "");
        assertEquals(expResult, result);
    }

    /**
     * Test of toStringAlt method, of class ImaginaryQuadraticInteger. For 
     * methods that return Strings, spaces are desirable but not required.
     * Therefore the tests should strip out spaces before asserting equality. If
     * the test of the toString method fails, the result of this test is 
     * irrelevant.
     */
    @Ignore
    @Test
    public void testToStringAlt() {
        System.out.println("toStringAlt");
        String expResult, result;
        ImaginaryQuadraticInteger currIQI;
        int nonThetaPart;
        // Treating the ring of Eisenstein integers as a special case
        for (int a = -32; a < 32; a++) {
            for (int b = -9; b < 9; b++) {
                if ((a % 2) == (b % 2)) {
                    nonThetaPart = (a + b)/2;
                    if (nonThetaPart == 0) {
                        expResult = b + "\u03C9";
                    } else {
                        expResult = nonThetaPart + "+" + b + "\u03C9";
                    }
                    expResult = expResult.replace("+-", "-");
                    expResult = expResult.replace("+1\u03C9", "+\u03C9");
                    expResult = expResult.replace("-1\u03C9", "-\u03C9");
                    if (expResult.equals("0\u03C9")) {
                        expResult = "0";
                    }
                    if (expResult.equals("1\u03C9")) {
                        expResult = "\u03C9";
                    }
                    expResult = expResult.replace("+0\u03C9", "");
                    // expResult = expResult.replace("-0\u03C9", ""); This one's unnecessary, right?
                    currIQI = new ImaginaryQuadraticInteger(a, b, RING_EISENSTEIN, 2);
                    result = currIQI.toStringAlt().replace(" ", "");
                    assertEquals(expResult, result);
                }
            }
        }
        /* Now to test in O_Q(sqrt(-7)) and some random ring with 
           "half-integers" */
        for (int m = -32; m < 32; m++) {
            for (int n = -9; n < 9; n++) {
                if ((m % 2) == (n % 2)) {
                    nonThetaPart = (m - n)/2;
                    if (nonThetaPart == 0) {
                        expResult = n + "\u03B8";
                    } else {
                        expResult = nonThetaPart + "+" + n + "\u03B8";
                    }
                    expResult = expResult.replace("+-", "-");
                    expResult = expResult.replace("+1\u03B8", "+\u03B8");
                    expResult = expResult.replace("-1\u03B8", "-\u03B8");
                    if (expResult.equals("0\u03B8")) {
                        expResult = "0";
                    }
                    if (expResult.equals("1\u03B8")) {
                        expResult = "\u03B8";
                    }
                    expResult = expResult.replace("+0\u03B8", "");
                    // expResult = expResult.replace("-0\u03C9", ""); This one's unnecessary, right?
                    currIQI = new ImaginaryQuadraticInteger(m, n, RING_OQI7, 2);
                    result = currIQI.toStringAlt().replace(" ", "");
                    assertEquals(expResult, result);
                    // No need to change expResult to test in ringRandomForAltTesting
                    currIQI = new ImaginaryQuadraticInteger(m, n, ringRandomForAltTesting, 2);
                    result = currIQI.toStringAlt().replace(" ", "");
                    assertEquals(expResult, result);
                }
            }
        }
        // For integers in rings without "half-integers," we expect toString() and toStringAlt() to give the same result.
        for (int i = 0; i < totalTestIntegers; i++) {
            if (!testIntegers.get(i).getRing().hasHalfIntegers()) {
                assertEquals(testIntegers.get(i).toString(), testIntegers.get(i).toStringAlt());
            }
        }
        // Lastly to test on a couple of complex units
        expResult = "i";
        result = IMAG_UNIT_I.toStringAlt();
        assertEquals(expResult, result);
        expResult = "-i";
        result = IMAG_UNIT_NEG_I.toStringAlt();
        assertEquals(expResult, result);
        expResult = "\u03C9";
        result = COMPLEX_CUBIC_ROOT_OF_UNITY.toStringAlt();
        assertEquals(expResult, result);
    }

    /**
     * Test of toASCIIString method, of class ImaginaryQuadraticInteger. For 
     * methods that return Strings, spaces are desirable but not required.
     * Therefore the tests should strip out spaces before asserting equality.
     */
    @Ignore
    @Test
    public void testToASCIIString() {
        System.out.println("toASCIIString");
        String expResult;
        if (randomRealPart == 0) {
            expResult = randomImagPart + "i";
        } else {
            expResult = randomRealPart + "+" + randomImagPart + "i";
        }
        expResult = expResult.replace("+-", "-");
        expResult = expResult.replace("+1i", "+i");
        expResult = expResult.replace("-1i", "-i");
        String result = testIntegers.get(0).toASCIIString().replace(" ", "");
        assertEquals(expResult, result);
        for (int i = 1; i < totalTestIntegers; i++) {
            if (testIntegers.get(i).getRing().hasHalfIntegers()) {
                expResult = randomRealForHalfInts + "/2+" + randomImagForHalfInts + "sqrt(" + testIntegers.get(i).getRing().getRadicand() + ")/2";
            } else {
                if (randomRealPart == 0) {
                    expResult = randomImagPart + "sqrt(" + testIntegers.get(i).getRing().getRadicand() + ")";
                } else {
                    expResult = randomRealPart + "+" + randomImagPart + "sqrt(" + testIntegers.get(i).getRing().getRadicand() + ")";
                }
            }
            expResult = expResult.replace("+-", "-");
            expResult = expResult.replace("+1sqrt", "+sqrt");
            expResult = expResult.replace("-1sqrt", "-sqrt");
            result = testIntegers.get(i).toASCIIString().replace(" ", "");
            assertEquals(expResult, result);
        }
        // Lastly to test on a couple of complex units
        expResult = "i";
        result = IMAG_UNIT_I.toASCIIString();
        assertEquals(expResult, result);
        expResult = "-i";
        result = IMAG_UNIT_NEG_I.toASCIIString();
        assertEquals(expResult, result);
        expResult = "-1/2+sqrt(-3)/2";
        result = COMPLEX_CUBIC_ROOT_OF_UNITY.toASCIIString().replace(" ", "");
        assertEquals(expResult, result);
    }

    /**
     * Test of toASCIIStringAlt method, of class ImaginaryQuadraticInteger. For 
     * methods that return Strings, spaces are desirable but not required.
     * Therefore the tests should strip out spaces before asserting equality.
     * If the test of the toASCIIString method fails, the result of this test is 
     * irrelevant.
     */
    @Ignore
    @Test
    public void testToASCIIStringAlt() {
        System.out.println("toASCIIStringAlt");
        String expResult, result;
        ImaginaryQuadraticInteger currIQI;
        int nonThetaPart;
        // Treating the ring of Eisenstein integers as a special case
        for (int a = -32; a < 32; a++) {
            for (int b = -9; b < 9; b++) {
                if ((a % 2) == (b % 2)) {
                    nonThetaPart = (a + b)/2;
                    if (nonThetaPart == 0) {
                        expResult = b + "omega";
                    } else {
                        expResult = nonThetaPart + "+" + b + "omega";
                    }
                    expResult = expResult.replace("+-", "-");
                    expResult = expResult.replace("+1omega", "+omega");
                    expResult = expResult.replace("-1omega", "-omega");
                    if (expResult.equals("0omega")) {
                        expResult = "0";
                    }
                    if (expResult.equals("1omega")) {
                        expResult = "omega";
                    }
                    expResult = expResult.replace("+0omega", "");
                    // expResult = expResult.replace("-0omega", ""); This one's unnecessary, right?
                    currIQI = new ImaginaryQuadraticInteger(a, b, RING_EISENSTEIN, 2);
                    result = currIQI.toASCIIStringAlt().replace(" ", "");
                    assertEquals(expResult, result);
                }
            }
        }
        /* Now to test in O_Q(sqrt(-7)) and some random ring with 
        "half-integers" */
        for (int m = -32; m < 32; m++) {
            for (int n = -9; n < 9; n++) {
                if ((m % 2) == (n % 2)) {
                    nonThetaPart = (m - n)/2;
                    if (nonThetaPart == 0) {
                        expResult = n + "theta";
                    } else {
                        expResult = nonThetaPart + "+" + n + "theta";
                    }
                    expResult = expResult.replace("+-", "-");
                    expResult = expResult.replace("+1theta", "+theta");
                    expResult = expResult.replace("-1theta", "-theta");
                    if (expResult.equals("0theta")) {
                        expResult = "0";
                    }
                    if (expResult.equals("1theta")) {
                        expResult = "theta";
                    }
                    expResult = expResult.replace("+0theta", "");
                    // expResult = expResult.replace("-0omega", ""); This one's unnecessary, right?
                    currIQI = new ImaginaryQuadraticInteger(m, n, RING_OQI7, 2);
                    result = currIQI.toASCIIStringAlt().replace(" ", "");
                    assertEquals(expResult, result);
                    // No need to change expResult to test in ringRandomForAltTesting
                    currIQI = new ImaginaryQuadraticInteger(m, n, ringRandomForAltTesting, 2);
                    result = currIQI.toASCIIStringAlt().replace(" ", "");
                    assertEquals(expResult, result);
                }
            }
        }
        /* For integers in rings without "half-integers," we expect 
        toASCIIString() and toASCIIStringAlt() to give the same result. */
        for (int i = 0; i < totalTestIntegers; i++) {
            if (!testIntegers.get(i).getRing().hasHalfIntegers()) {
                assertEquals(testIntegers.get(i).toASCIIString(), testIntegers.get(i).toASCIIStringAlt());
            }
        }
        // Lastly to test on a couple of complex units
        expResult = "i";
        result = IMAG_UNIT_I.toASCIIStringAlt();
        assertEquals(expResult, result);
        expResult = "-i";
        result = IMAG_UNIT_NEG_I.toASCIIStringAlt();
        assertEquals(expResult, result);
        expResult = "omega";
        result = COMPLEX_CUBIC_ROOT_OF_UNITY.toASCIIStringAlt();
        assertEquals(expResult, result);
    }
    
    /**
     * Test of toTeXString method, of class ImaginaryQuadraticInteger. For 
     * methods that return Strings, spaces are desirable but not required.
     * Therefore the tests should strip out spaces before asserting equality.
     */
    @Ignore
    @Test
    public void testToTeXString() {
        System.out.println("toTeXString");
        String expResult;
        if (randomRealPart == 0) {
            expResult = randomImagPart + "i";
        } else {
            expResult = randomRealPart + "+" + randomImagPart + "i";
        }
        expResult = expResult.replace("+-", "-");
        expResult = expResult.replace("+1i", "+i");
        expResult = expResult.replace("-1i", "-i");
        String result = testIntegers.get(0).toTeXString().replace(" ", "");
        assertEquals(expResult, result);
        for (int i = 1; i < totalTestIntegers; i++) {
            if (testIntegers.get(i).getRing().hasHalfIntegers()) {
                expResult = "\\frac{" + randomRealForHalfInts + "}{2}+\\frac{" + randomImagForHalfInts + "\\sqrt{" + testIntegers.get(i).getRing().getRadicand() + "}}{2}";
            } else {
                if (randomRealPart == 0) {
                    expResult = randomImagPart + "\\sqrt{" + testIntegers.get(i).getRing().getRadicand() + "}";
                } else {
                    expResult = randomRealPart + "+" + randomImagPart + "\\sqrt{" + testIntegers.get(i).getRing().getRadicand() + "}";
                }
            }
            expResult = expResult.replace("-1\\sqrt", "-\\sqrt");
            expResult = expResult.replace("+1\\sqrt", "+\\sqrt");
            expResult = expResult.replace("\\frac{-", "-\\frac{");
            expResult = expResult.replace("+-", "-");
            result = testIntegers.get(i).toTeXString().replace(" ", "");
            assertEquals(expResult, result);
        }
        // Lastly to test on a couple of complex units
        expResult = "i";
        result = IMAG_UNIT_I.toTeXString();
        assertEquals(expResult, result);
        expResult = "-i";
        result = IMAG_UNIT_NEG_I.toTeXString();
        assertEquals(expResult, result);
        expResult = "-\\frac{1}{2}+\\frac{\\sqrt{-3}}{2}";
        result = COMPLEX_CUBIC_ROOT_OF_UNITY.toTeXString().replace(" ", "");
        assertEquals(expResult, result);
        /* This last one is to make sure that a least significant digit that is 
           1 but is not also the most significant digit does not get erroneously 
           chopped off */
        ImaginaryQuadraticInteger norm97Eisen = new ImaginaryQuadraticInteger(5, 11, NumberTheoreticFunctionsCalculator.RING_EISENSTEIN, 2);
        expResult = "\\frac{5}{2}+\\frac{11\\sqrt{-3}}{2}";
        result = norm97Eisen.toTeXString().replace(" ", "");
        assertEquals(expResult, result);
    }
    
    /**
     * Test of toTeXStringSingleDenom method, of class ImaginaryQuadraticInteger. For 
     * methods that return Strings, spaces are desirable but not required.
     * Therefore the tests should strip out spaces before asserting equality.
     */
    @Ignore
    @Test
    public void testToTeXStringSingleDenom() {
        System.out.println("toTeXStringSingleDenom");
        String expResult, result;
        for (int i = 0; i < totalTestIntegers; i++) {
            if (testIntegers.get(i).getDenominator() == 2) {
                expResult = "\\frac{" + randomRealForHalfInts + "+" + randomImagForHalfInts + "\\sqrt{" + testIntegers.get(i).getRing().getRadicand() + "}}{2}";
                expResult = expResult.replace("+-", "-");
                result = testIntegers.get(i).toTeXStringSingleDenom().replace(" ", "");
                assertEquals(expResult, result);
            } else {
                assertEquals(testIntegers.get(i).toTeXString(), testIntegers.get(i).toTeXStringSingleDenom());
            }
        }
        // Lastly to test on a couple of complex units
        expResult = "i";
        result = IMAG_UNIT_I.toTeXStringSingleDenom();
        assertEquals(expResult, result);
        expResult = "-i";
        result = IMAG_UNIT_NEG_I.toTeXStringSingleDenom();
        assertEquals(expResult, result);
        expResult = "\\frac{-1+\\sqrt{-3}}{2}";
        result = COMPLEX_CUBIC_ROOT_OF_UNITY.toTeXStringSingleDenom().replace(" ", "");
        assertEquals(expResult, result);
        /* This last one is to make sure that a least significant digit that is 
           1 but is not also the most significant digit does not get erroneously 
           chopped off */
        ImaginaryQuadraticInteger norm97Eisen = new ImaginaryQuadraticInteger(5, 11, NumberTheoreticFunctionsCalculator.RING_EISENSTEIN, 2);
        expResult = "\\frac{5+11\\sqrt{-3}}{2}";
        result = norm97Eisen.toTeXStringSingleDenom().replace(" ", "");
        assertEquals(expResult, result);
    }

    /**
     * Test of toTeXStringAlt method, of class ImaginaryQuadraticInteger. For 
     * methods that return Strings, spaces are desirable but not required.
     * Therefore the tests should strip out spaces before asserting equality.
     * If the test of the toTeXString method fails, the result of this test is 
     * irrelevant.
     */
    @Ignore
    @Test
    public void testToTeXStringAlt() {
        System.out.println("toTeXStringAlt");
        String expResult, result;
        ImaginaryQuadraticInteger currIQI;
        int nonThetaPart;
        // Treating the ring of Eisenstein integers as a special case
        for (int a = -32; a < 32; a++) {
            for (int b = -9; b < 9; b++) {
                if ((a % 2) == (b % 2)) {
                    nonThetaPart = (a + b)/2;
                    if (nonThetaPart == 0) {
                        expResult = b + "\\omega";
                    } else {
                        expResult = nonThetaPart + "+" + b + "\\omega";
                    }
                    expResult = expResult.replace("+-", "-");
                    expResult = expResult.replace("+1\\omega", "+\\omega");
                    expResult = expResult.replace("-1\\omega", "-\\omega");
                    if (expResult.equals("0\\omega")) {
                        expResult = "0";
                    }
                    if (expResult.equals("1\\omega")) {
                        expResult = "\\omega";
                    }
                    expResult = expResult.replace("+0\\omega", "");
                    currIQI = new ImaginaryQuadraticInteger(a, b, RING_EISENSTEIN, 2);
                    result = currIQI.toTeXStringAlt().replace(" ", "");
                    assertEquals(expResult, result);
                }
            }
        }
        /* Now to test in O_Q(sqrt(-7)) and some random ring with 
        "half-integers" */
        for (int m = -32; m < 32; m++) {
            for (int n = -9; n < 9; n++) {
                if ((m % 2) == (n % 2)) {
                    nonThetaPart = (m - n)/2;
                    if (nonThetaPart == 0) {
                        expResult = n + "\\theta";
                    } else {
                        expResult = nonThetaPart + "+" + n + "\\theta";
                    }
                    expResult = expResult.replace("+-", "-");
                    expResult = expResult.replace("+1\\theta", "+\\theta");
                    expResult = expResult.replace("-1\\theta", "-\\theta");
                    if (expResult.equals("0\\theta")) {
                        expResult = "0";
                    }
                    if (expResult.equals("1\\theta")) {
                        expResult = "\\theta";
                    }
                    expResult = expResult.replace("+0\\theta", "");
                    // expResult = expResult.replace("-0omega", ""); This one's unnecessary, right?
                    currIQI = new ImaginaryQuadraticInteger(m, n, RING_OQI7, 2);
                    result = currIQI.toTeXStringAlt().replace(" ", "");
                    assertEquals(expResult, result);
                    // No need to change expResult to test in ringRandomForAltTesting
                    currIQI = new ImaginaryQuadraticInteger(m, n, ringRandomForAltTesting, 2);
                    result = currIQI.toTeXStringAlt().replace(" ", "");
                    assertEquals(expResult, result);
                }
            }
        }
        /* For integers in rings without "half-integers," we expect 
        toTeXString() and toTeXStringAlt() to give the same result. */
        for (int i = 0; i < totalTestIntegers; i++) {
            if (!testIntegers.get(i).getRing().hasHalfIntegers()) {
                assertEquals(testIntegers.get(i).toTeXString(), testIntegers.get(i).toTeXStringAlt());
            }
        }
        // Lastly to test on a couple of complex units
        expResult = "i";
        result = IMAG_UNIT_I.toTeXStringAlt();
        assertEquals(expResult, result);
        expResult = "-i";
        result = IMAG_UNIT_NEG_I.toTeXStringAlt();
        assertEquals(expResult, result);
        expResult = "\\omega";
        result = COMPLEX_CUBIC_ROOT_OF_UNITY.toTeXStringAlt();
        assertEquals(expResult, result);
    }
    
    /**
     * Test of toHTMLString method, of class ImaginaryQuadraticInteger. For 
     * methods that return Strings, spaces are desirable but not required.
     * Therefore the tests should strip out spaces before asserting equality.
     */
    @Ignore
    @Test
    public void testToHTMLString() {
        System.out.println("toHTMLString");
        String expResult;
        if (randomRealPart == 0) {
            expResult = randomImagPart + "<i>i</i>";
        } else {
            expResult = randomRealPart + "+" + randomImagPart + "<i>i</i>";
        }
        expResult = expResult.replace("+-", "-");
        expResult = expResult.replace("+1<i>i</i>", "+<i>i</i>");
        expResult = expResult.replace("-1<i>i</i>", "-<i>i</i>");
        expResult = expResult.replace("-", "&minus;");
        String result = testIntegers.get(0).toHTMLString().replace(" ", "");
        assertEquals(expResult, result);
        for (int i = 1; i < totalTestIntegers; i++) {
            if (testIntegers.get(i).getRing().hasHalfIntegers()) {
                expResult = randomRealForHalfInts + "/2+" + randomImagForHalfInts + "&radic;(" + testIntegers.get(i).getRing().getRadicand() + ")/2";
            } else {
                if (randomRealPart == 0) {
                    expResult = randomImagPart + "&radic;(" + testIntegers.get(i).getRing().getRadicand() + ")";
                } else {
                    expResult = randomRealPart + "+" + randomImagPart + "&radic;(" + testIntegers.get(i).getRing().getRadicand() + ")";
                }
            }
            expResult = expResult.replace("+-", "-");
            expResult = expResult.replace("+1&radic;", "+&radic;");
            expResult = expResult.replace("-1&radic;", "-&radic;");
            expResult = expResult.replace("-", "&minus;");
            result = testIntegers.get(i).toHTMLString().replace(" ", "");
            assertEquals(expResult, result);
        }
        // Lastly to test on a couple of complex units
        expResult = "<i>i</i>";
        result = IMAG_UNIT_I.toHTMLString();
        assertEquals(expResult, result);
        expResult = "&minus;<i>i</i>";
        result = IMAG_UNIT_NEG_I.toHTMLString();
        assertEquals(expResult, result);
        expResult = "&minus;1/2+&radic;(&minus;3)/2";
        result = COMPLEX_CUBIC_ROOT_OF_UNITY.toHTMLString().replace(" ", "");
        assertEquals(expResult, result);
        /* This last one is to make sure that a least significant digit that is 
           1 but is not also the most significant digit does not get erroneously 
           chopped off */
        ImaginaryQuadraticInteger norm97Eisen = new ImaginaryQuadraticInteger(5, 11, NumberTheoreticFunctionsCalculator.RING_EISENSTEIN, 2);
        expResult = "5/2+11&radic;(&minus;3)/2";
        result = norm97Eisen.toHTMLString().replace(" ", "");
        assertEquals(expResult, result);
    }

    /**
     * Test of toHTMLStringAlt method, of class ImaginaryQuadraticInteger. For 
     * methods that return Strings, spaces are desirable but not required.
     * Therefore the tests should strip out spaces before asserting equality.
     * If the test of the toHTMLString method fails, the result of this test is 
     * irrelevant.
     */
    @Ignore
    @Test
    public void testToHTMLStringAlt() {
        System.out.println("toHTMLStringAlt");
        String expResult, result;
        ImaginaryQuadraticInteger currIQI;
        int nonThetaPart;
        // Treating the ring of Eisenstein integers as a special case
        for (int a = -32; a < 32; a++) {
            for (int b = -9; b < 9; b++) {
                if ((a % 2) == (b % 2)) {
                    nonThetaPart = (a + b)/2;
                    if (nonThetaPart == 0) {
                        expResult = b + "&omega;";
                    } else {
                        expResult = nonThetaPart + "+" + b + "&omega;";
                    }
                    expResult = expResult.replace("+-", "-");
                    expResult = expResult.replace("+1&omega;", "+&omega;");
                    expResult = expResult.replace("-1&omega;", "-&omega;");
                    if (expResult.equals("0&omega;")) {
                        expResult = "0";
                    }
                    if (expResult.equals("1&omega;")) {
                        expResult = "&omega;";
                    }
                    expResult = expResult.replace("+0&omega;", "");
                    expResult = expResult.replace("-", "&minus;");
                    currIQI = new ImaginaryQuadraticInteger(a, b, RING_EISENSTEIN, 2);
                    result = currIQI.toHTMLStringAlt().replace(" ", "");
                    assertEquals(expResult, result);
                }
            }
        }
        /* Now to test in O_Q(sqrt(-7)) and some random ring with 
        "half-integers" */
        for (int m = -32; m < 32; m++) {
            for (int n = -9; n < 9; n++) {
                if ((m % 2) == (n % 2)) {
                    nonThetaPart = (m - n)/2;
                    if (nonThetaPart == 0) {
                        expResult = n + "&theta;";
                    } else {
                        expResult = nonThetaPart + "+" + n + "&theta;";
                    }
                    expResult = expResult.replace("+-", "-");
                    expResult = expResult.replace("+1&theta;", "+&theta;");
                    expResult = expResult.replace("-1&theta;", "-&theta;");
                    if (expResult.equals("0&theta;")) {
                        expResult = "0";
                    }
                    if (expResult.equals("1&theta;")) {
                        expResult = "&theta;";
                    }
                    expResult = expResult.replace("+0&theta;", "");
                    expResult = expResult.replace("-", "&minus;");
                    currIQI = new ImaginaryQuadraticInteger(m, n, RING_OQI7, 2);
                    result = currIQI.toHTMLStringAlt().replace(" ", "");
                    assertEquals(expResult, result);
                    // No need to change expResult to test in ringRandomForAltTesting
                    currIQI = new ImaginaryQuadraticInteger(m, n, ringRandomForAltTesting, 2);
                    result = currIQI.toHTMLStringAlt().replace(" ", "");
                    assertEquals(expResult, result);
                }
            }
        }
        /* For integers in rings without "half-integers," we expect 
        toHTMLString() and toHTMLStringAlt() to give the same result. */
        for (int i = 0; i < totalTestIntegers; i++) {
            if (!testIntegers.get(i).getRing().hasHalfIntegers()) {
                assertEquals(testIntegers.get(i).toHTMLString(), testIntegers.get(i).toHTMLStringAlt());
            }
        }
        // Lastly to test on a couple of complex units
        expResult = "<i>i</i>";
        result = IMAG_UNIT_I.toHTMLStringAlt();
        assertEquals(expResult, result);
        expResult = "&minus;<i>i</i>";
        result = IMAG_UNIT_NEG_I.toHTMLStringAlt();
        assertEquals(expResult, result);
        expResult = "&omega;";
        result = COMPLEX_CUBIC_ROOT_OF_UNITY.toHTMLStringAlt();
        assertEquals(expResult, result);
    }
    
    /**
     * Test of hashCode method, of class ImaginaryQuadraticInteger. It is 
     * expected that if two ImaginaryQuadraticInteger objects are equal, their 
     * hash codes are equal as well. It is also expected that a + b&radic;c and 
     * a + b&radic;d will get different hash codes. But it is definitely not 
     * expected that hash codes will be unique among all possible 
     * ImaginaryQuadraticInteger objects.
     */
    @Test
    public void testHashCode() {
        System.out.println("hashCode");
        ImaginaryQuadraticInteger temporaryHold;
        int testHash, tempHash;
        int prevHash = 0;
        for (int i = 0; i < totalTestIntegers; i++) {
            testHash = testIntegers.get(i).hashCode();
            if (testIntegers.get(i).getRing().hasHalfIntegers()) {
                temporaryHold = new ImaginaryQuadraticInteger(randomRealForHalfInts, randomImagForHalfInts, testIntegers.get(i).getRing(), 2);
            } else {
                temporaryHold = new ImaginaryQuadraticInteger(randomRealPart, randomImagPart, testIntegers.get(i).getRing());
            }
            tempHash = temporaryHold.hashCode();
            System.out.println(testIntegers.get(i).toASCIIString() + " hashed to " + testHash);
            System.out.println(temporaryHold.toASCIIString() + " hashed to " + tempHash);
            assertEquals(testHash, tempHash);
            assertFalse(testHash == prevHash);
            prevHash = testHash;
        }
        /* Now to test purely real integers register as equal regardless of what 
           imaginary quadratic ring they might be from */
        ImaginaryQuadraticInteger altZeroIQI = new ImaginaryQuadraticInteger(0, 0, RING_ZI2);
        assertEquals(altZeroIQI, zeroIQI);
        for (int j = 0; j < totalTestIntegers - 1; j++) {
            temporaryHold = new ImaginaryQuadraticInteger(testNormsRealParts.get(j), 0, testNorms.get(totalTestIntegers - 1).getRing());
            tempHash = temporaryHold.hashCode();
            testHash = testNorms.get(j).hashCode();
            System.out.println(temporaryHold.toString() + " from " + temporaryHold.getRing().toASCIIString() + " hashed as " + tempHash);
            System.out.println(testNorms.get(j).toString() + " from " + testNorms.get(j).getRing().toASCIIString() + " hashed as " + testHash);
            assertEquals(tempHash, testHash);
        }
    }
    
    /**
     * Test of equals method, of class ImaginaryQuadraticInteger.
     */
    @Test
    public void testEquals() {
        System.out.println("equals");
        ImaginaryQuadraticInteger temporaryHold, transitiveHold, kindaDiffZero;
        for (int i = 0; i < totalTestIntegers; i++) {
            assertTrue(testIntegers.get(i).equals(testIntegers.get(i))); // Reflexive test
            if (testIntegers.get(i).getRing().hasHalfIntegers()) {
                temporaryHold = new ImaginaryQuadraticInteger(randomRealForHalfInts, randomImagForHalfInts, testIntegers.get(i).getRing(), 2);
                transitiveHold = new ImaginaryQuadraticInteger(randomRealForHalfInts, randomImagForHalfInts, testIntegers.get(i).getRing(), 2);
            } else {
                temporaryHold = new ImaginaryQuadraticInteger(randomRealPart, randomImagPart, testIntegers.get(i).getRing());
                transitiveHold = new ImaginaryQuadraticInteger(randomRealPart, randomImagPart, testIntegers.get(i).getRing());
            }
            assertTrue(testIntegers.get(i).equals(testIntegers.get(i))); // First consistency test
            assertEquals(testIntegers.get(i), temporaryHold);
            assertEquals(temporaryHold, testIntegers.get(i)); // Symmetric test
            assertEquals(temporaryHold, transitiveHold);
            assertEquals(transitiveHold, testIntegers.get(i)); // Transitive test
            assertTrue(testIntegers.get(i).equals(testIntegers.get(i))); // Second consistency test
            // assertFalse(testIntegers.get(i).equals(null)); // Null test is apparently unnecessary
        }
        for (int j = 0; j < totalTestIntegers - 1; j++) {
            assertFalse(testIntegers.get(j).equals(testIntegers.get(j + 1)));
            assertFalse(testIntegers.get(j + 1).equals(testIntegers.get(j))); // Symmetric test for not equals
            temporaryHold = new ImaginaryQuadraticInteger(testNormsRealParts.get(j), 0, testNorms.get(j + 1).getRing());
            assertEquals(testNorms.get(j), temporaryHold);
            kindaDiffZero = new ImaginaryQuadraticInteger(0, 0, testIntegers.get(j + 1).getRing());
            assertEquals(zeroIQI, kindaDiffZero); // Making sure purely real integers can register as equal
        }
    }
    
    /* (TEMP JAVADOC DISABLE) *
     * Test of equalsInt, of class ImaginaryQuadraticInteger.
     */
    //(AT)Test
//    public void testEqualsInt() {
//        System.out.println("equalsInt");
//        for (int i = 0; i < totalTestIntegers; i++) {
//            assertTrue(testNorms.get(i).equalsInt(testNormsRealParts.get(i)));
//            assertFalse(testIntegers.get(i).equalsInt(randomRealPart));
//            assertFalse(testIntegers.get(i).equalsInt(randomRealForHalfInts));
//        }
//        assertTrue(zeroIQI.equalsInt(0));
//    }
    
    /**
     * Test of parseQuadraticInteger, of class ImaginaryQuadraticInteger, 
     * inherited from QuadraticInteger. Whatever is output by toString, 
     * toStringAlt, toASCIIString, toASCIIStringAlt, toTeXString, 
     * toTeXStringSingleDenom, toTeXStringAlt, toHTMLString or toHTMLStringAlt 
     * should be parseable by parseQuadraticInteger. With the following caveats: 
     * &omega; should always be understood to mean -1/2 + sqrt(-3)/2 and &phi; 
     * should be understood to mean 1/2 + sqrt(5)/2, while &theta; means 1/2 
     * + sqrt(d)/2 with d = 1 mod 4, but d may be ambiguous.
     */
    @Ignore
    @Test
    public void testParseQuadraticInteger() {
        System.out.println("parseQuadraticInteger");
        String numberString;
        QuadraticInteger numberIQI;
        for (int i = 0; i < totalTestIntegers; i++) {
            numberString = testIntegers.get(i).toString();
            numberIQI = QuadraticInteger.parseQuadraticInteger(numberString);
            assertEquals(testIntegers.get(i), numberIQI);
            numberString = testIntegers.get(i).toStringAlt();
            numberIQI = QuadraticInteger.parseQuadraticInteger(testIntegers.get(i).getRing(), numberString);
            assertEquals(testIntegers.get(i), numberIQI);
            numberString = testIntegers.get(i).toASCIIString();
            numberIQI = QuadraticInteger.parseQuadraticInteger(numberString);
            assertEquals(testIntegers.get(i), numberIQI);
            numberString = testIntegers.get(i).toASCIIStringAlt();
            numberIQI = QuadraticInteger.parseQuadraticInteger(testIntegers.get(i).getRing(), numberString);
            assertEquals(testIntegers.get(i), numberIQI);
            numberString = testIntegers.get(i).toTeXString();
            numberIQI = QuadraticInteger.parseQuadraticInteger(numberString);
            assertEquals(testIntegers.get(i), numberIQI);
            numberString = testIntegers.get(i).toTeXStringSingleDenom();
            numberIQI = QuadraticInteger.parseQuadraticInteger(numberString);
            assertEquals(testIntegers.get(i), numberIQI);
            numberString = testIntegers.get(i).toTeXStringAlt();
            numberIQI = QuadraticInteger.parseQuadraticInteger(testIntegers.get(i).getRing(), numberString);
            assertEquals(testIntegers.get(i), numberIQI);
            numberString = testIntegers.get(i).toHTMLString();
            numberIQI = QuadraticInteger.parseQuadraticInteger(numberString);
            assertEquals(testIntegers.get(i), numberIQI);
            numberString = testIntegers.get(i).toHTMLStringAlt();
            numberIQI = QuadraticInteger.parseQuadraticInteger(testIntegers.get(i).getRing(), numberString);
            assertEquals(testIntegers.get(i), numberIQI);
        }
        // A few special cases to check
        numberString = "i";
        numberIQI = new ImaginaryQuadraticInteger(0, 1, RING_GAUSSIAN);
        assertEquals(numberIQI, QuadraticInteger.parseQuadraticInteger(numberString));
        numberString = "0 + i";
        assertEquals(numberIQI, QuadraticInteger.parseQuadraticInteger(numberString));
        numberString = "-sqrt(-2)";
        numberIQI = new ImaginaryQuadraticInteger(0, -1, RING_ZI2);
        assertEquals(numberIQI, QuadraticInteger.parseQuadraticInteger(numberString));
        numberString = "0 - sqrt(-2)";
        assertEquals(numberIQI, QuadraticInteger.parseQuadraticInteger(numberString));
        /* Lastly, to check the appropriate exception is thrown for non-numeric 
           strings */
        numberString = "one plus imaginary unit";
        try {
            numberIQI = QuadraticInteger.parseQuadraticInteger(numberString);
            fail("Attempting to call parseImaginaryQuadraticInteger on \"" + numberString + "\" should have triggered NumberFormatException, not given " + numberIQI.toASCIIString() + ".");
        } catch (NumberFormatException nfe) {
            System.out.println("Attempting to call parseImaginaryQuadraticInteger on \"" + numberString + "\" correctly triggered NumberFormatException: " + nfe.getMessage());
        }
    }
    
    /**
     * Test of optional behaviors of parseImaginaryQuadraticInteger, of class 
     * ImaginaryQuadraticInteger. This includes recognizing "j" as an 
     * alternative notation for &radic;-1. If the optional behaviors are 
     * required, change the print statements under catch {@link 
     * NumberFormatException} to fails.
     */
    @Ignore
    @Test
    public void testParseQuadraticIntegerOptions() {
        System.out.println("parseQuadraticInteger, optional behaviors");
        String numberString = "j";
        QuadraticInteger expResult = new ImaginaryQuadraticInteger(0, 1, RING_GAUSSIAN);
        QuadraticInteger result;
        try {
            result = QuadraticInteger.parseQuadraticInteger(numberString);
            assertEquals(expResult, result);
        } catch (NumberFormatException nfe) {
            System.out.println("Testing the option to use 'j' instead of 'i' triggered NumberFormatException \"" + nfe.getMessage() + "\"");
            System.out.println("This is an acceptable but not preferable response for dealing with \"" + numberString + "\".");
        } catch (Exception e) {
            String failMessage = "\"" + numberString + "\" should not have caused " + e.getClass().getName() + "\"" + e.getMessage() + "\"";
            fail(failMessage);
        }
        numberString = "j + 1";
        expResult = expResult.plus(1);
        try {
            result = QuadraticInteger.parseQuadraticInteger(numberString);
            assertEquals(expResult, result);
        } catch (NumberFormatException nfe) {
            System.out.println("Testing an optional behavior triggered NumberFormatException \"" + nfe.getMessage() + "\"");
            System.out.println("This is an acceptable but not preferable response for dealing with \"" + numberString + "\".");
        } catch (Exception e) {
            String failMessage = "\"" + numberString + "\" should not have caused " + e.getClass().getName() + "\"" + e.getMessage() + "\"";
            fail(failMessage);
        }
        numberString = "\u221A-7 - 1";
        expResult = new ImaginaryQuadraticInteger(1, 1, RING_OQI7);
        try {
            result = QuadraticInteger.parseQuadraticInteger(numberString);
            assertEquals(expResult, result);
        } catch (NumberFormatException nfe) {
            System.out.println("Testing an optional behavior triggered NumberFormatException \"" + nfe.getMessage() + "\"");
            System.out.println("This is an acceptable but not preferable response for dealing with \"" + numberString + "\".");
        } catch (Exception e) {
            String failMessage = "\"" + numberString + "\" should not have caused " + e.getClass().getName() + "\"" + e.getMessage() + "\"";
            fail(failMessage);
        }
        numberString = "";
        try {
            result = QuadraticInteger.parseQuadraticInteger(numberString);
            assertEquals(zeroIQI, result);
        } catch (NumberFormatException nfe) {
            System.out.println("Testing the option to have an empty String stand for 0 triggered NumberFormatException \"" + nfe.getMessage() + "\"");
            System.out.println("This is an acceptable response for dealing with an empty String.");
        } catch (Exception e) {
            String failMessage = "Empty String should not have caused " + e.getClass().getName() + " \"" + e.getMessage() + "\"";
            fail(failMessage);
        }
        // Try the empty String again but this time specifying Z[sqrt(-2)]
        try {
            result = QuadraticInteger.parseQuadraticInteger(RING_ZI2, numberString);
            assertEquals(zeroIQI, result);
        } catch (NumberFormatException nfe) {
            System.out.println("Testing the option to have an empty String stand for 0 triggered NumberFormatException \"" + nfe.getMessage() + "\"");
            System.out.println("This is an acceptable response for dealing with an empty String even if a ring is specified.");
        } catch (Exception e) {
            String failMessage = "Empty String should not have caused " + e.getClass().getName() + " \"" + e.getMessage() + "\"";
            fail(failMessage);
        }
    }
    
    /* (TEMP JAVADOC DISABLE) *
     * Test of parseQuaterImaginary of class ImaginaryQuadraticInteger.
     */
    //(AT)Test
//    public void testParseQuaterImaginary() {
//        System.out.println("parseQuaterImaginary");
//        String numberString = "10";
//        ImaginaryQuadraticInteger expResult = new ImaginaryQuadraticInteger(0, 2, ringGaussian);
//        ImaginaryQuadraticInteger result = ImaginaryQuadraticInteger.parseQuaterImaginary(numberString);
//        assertEquals(expResult, result);
//        numberString = " 3211 "; // Contains spaces to test these are indeed stripped out
//        expResult = new ImaginaryQuadraticInteger(-7, -22, ringGaussian);
//        result = ImaginaryQuadraticInteger.parseQuaterImaginary(numberString);
//        assertEquals(expResult, result);
//        DecimalFormatSymbols dfs = new DecimalFormatSymbols();
//        char decimalDot = dfs.getDecimalSeparator();
//        numberString = "10" + decimalDot + "200";
//        result = ImaginaryQuadraticInteger.parseQuaterImaginary(numberString);
//        assertEquals(IMAG_UNIT_I, result);
//        numberString = "10" + decimalDot + "3";
//        try {
//            result = ImaginaryQuadraticInteger.parseQuaterImaginary(numberString);
//            String failMessage = "\"" + numberString + "\" should have triggered NumberFormatException, not given result " + result.toASCIIString();
//            fail(failMessage);
//        } catch (NumberFormatException nfe) {
//            System.out.println("\"" + numberString + "\" correctly triggered NumberFormatException \"" + nfe.getMessage() + "\"");
//        } catch (Exception e) {
//            String failMessage = "\"" + numberString + "\" should not have triggered " + e.getClass().getName() + " \"" + e.getMessage() + "\"";
//            fail(failMessage);
//        }
//        numberString = "not actually a number at all this time, sorry";
//        try {
//            result = ImaginaryQuadraticInteger.parseQuaterImaginary(numberString);
//            String failMessage = "\"" + numberString + "\" should have triggered NumberFormatException, not given result " + result.toASCIIString();
//            fail(failMessage);
//        } catch (NumberFormatException nfe) {
//            System.out.println("\"" + numberString + "\" correctly triggered NumberFormatException \"" + nfe.getMessage() + "\"");
//        } catch (Exception e) {
//            String failMessage = "Empty String should not have caused " + e.getClass().getName() + " \"" + e.getMessage() + "\"";
//            fail(failMessage);
//        }
//        numberString = "";
//        try {
//            result = ImaginaryQuadraticInteger.parseQuaterImaginary(numberString);
//            assertEquals(zeroIQI, result);
//        } catch (NumberFormatException nfe) {
//            System.out.println("It is acceptable for an empty String to trigger NumberFormatException \"" + nfe.getMessage() + "\"");
//        } catch (Exception e) {
//            String failMessage = "\"" + numberString + "\" should not have triggered " + e.getClass().getName() + " \"" + e.getMessage() + "\"";
//            fail(failMessage);
//        }
//    }
    
    /**
     * Test of parseQuaterImaginary of class ImaginaryQuadraticInteger.
     */
    @Test
    public void testParseQuaterImaginary() {
        System.out.println("parseQuaterImaginary");
        String numberString = "10";
        ImaginaryQuadraticInteger expResult = new ImaginaryQuadraticInteger(0, 2, RING_GAUSSIAN);
        QuadraticInteger result = ImaginaryQuadraticInteger.parseQuaterImaginary(numberString);
        assertEquals(expResult, result);
        numberString = " 3211 "; // Contains spaces to test these are indeed stripped out
        expResult = new ImaginaryQuadraticInteger(-7, -22, RING_GAUSSIAN);
        result = ImaginaryQuadraticInteger.parseQuaterImaginary(numberString);
        assertEquals(expResult, result);
        DecimalFormatSymbols dfs = new DecimalFormatSymbols();
        char decimalDot = dfs.getDecimalSeparator();
        numberString = "10" + decimalDot + "200";
        result = ImaginaryQuadraticInteger.parseQuaterImaginary(numberString);
        assertEquals(NumberTheoreticFunctionsCalculator.IMAG_UNIT_I, result);
        numberString = "10" + decimalDot + "3";
        try {
            result = ImaginaryQuadraticInteger.parseQuaterImaginary(numberString);
            String failMessage = "\"" + numberString + "\" should have triggered NumberFormatException, not given result " + result.toASCIIString();
            fail(failMessage);
        } catch (NumberFormatException nfe) {
            System.out.println("\"" + numberString + "\" correctly triggered NumberFormatException \"" + nfe.getMessage() + "\"");
        } catch (Exception e) {
            String failMessage = "\"" + numberString + "\" should not have triggered " + e.getClass().getName() + " \"" + e.getMessage() + "\"";
            fail(failMessage);
        }
        numberString = "not actually a number at all this time, sorry";
        try {
            result = ImaginaryQuadraticInteger.parseQuaterImaginary(numberString);
            String failMessage = "\"" + numberString + "\" should have triggered NumberFormatException, not given result " + result.toASCIIString();
            fail(failMessage);
        } catch (NumberFormatException nfe) {
            System.out.println("\"" + numberString + "\" correctly triggered NumberFormatException \"" + nfe.getMessage() + "\"");
        } catch (Exception e) {
            String failMessage = "Empty String should not have caused " + e.getClass().getName() + " \"" + e.getMessage() + "\"";
            fail(failMessage);
        }
        numberString = "";
        try {
            result = ImaginaryQuadraticInteger.parseQuaterImaginary(numberString);
            assertEquals(zeroIQI, result);
        } catch (NumberFormatException nfe) {
            System.out.println("It is acceptable for an empty String to trigger NumberFormatException \"" + nfe.getMessage() + "\"");
        } catch (Exception e) {
            String failMessage = "\"" + numberString + "\" should not have triggered " + e.getClass().getName() + " \"" + e.getMessage() + "\"";
            fail(failMessage);
        }
    }

    /**
     * Test of plus method, of class ImaginaryQuadraticInteger.
     */
    @Test
    public void testPlus() {
        System.out.println("plus");
        ImaginaryQuadraticRing currRing;
        QuadraticInteger expResult, result, testAddendA, testAddendB;
        int currDenom;
        String failMessage;
        for (int iterDiscr = -1; iterDiscr > -200; iterDiscr--) {
            if (NumberTheoreticFunctionsCalculator.isSquareFree(iterDiscr)) {
                currRing = new ImaginaryQuadraticRing(iterDiscr);
                if (currRing.hasHalfIntegers()) {
                    currDenom = 2;
                } else {
                    currDenom = 1;
                }
                for (int v = -3; v < 48; v += 2) {
                    for (int w = -3; w < 48; w += 2) {
                        testAddendA = new ImaginaryQuadraticInteger(v, w, currRing, currDenom);
                        for (int x = -3; x < 48; x += 2) {
                            for (int y = -3; y < 48; y += 2) {
                                testAddendB = new ImaginaryQuadraticInteger(x, y, currRing, currDenom);
                                expResult = new ImaginaryQuadraticInteger(v + x, w + y, currRing, currDenom);
                                failMessage = "Adding two integers from the same ring should not have triggered AlgebraicDegreeOverflowException \"";
                                try {
                                    result = testAddendA.plus(testAddendB);
                                    assertEquals(expResult, result);
                                } catch (AlgebraicDegreeOverflowException adoe) {
                                    failMessage = failMessage + adoe.getMessage() + "\"";
                                    fail(failMessage);
                                }
                            }
                            // Now to test plus(int)
                            if (currRing.hasHalfIntegers()) {
                                expResult = new ImaginaryQuadraticInteger(v + 2 * x, w, currRing, 2);
                            } else {
                                expResult = new ImaginaryQuadraticInteger(v + x, w, currRing);
                            }
                            result = testAddendA.plus(x);
                            assertEquals(expResult, result);
                        }
                    }
                }
            }
        }
        for (int i = 0; i < totalTestIntegers; i++) {
            // Testing that adding additive inverses give 0 each time
            failMessage = "Adding test integer to its additive inverse should not have triggered AlgebraicDegreeOverflowException \"";
            try {
                result = testIntegers.get(i).plus(testAdditiveInverses.get(i));
                assertEquals(zeroIQI, result);
            } catch (AlgebraicDegreeOverflowException adoe) {
                failMessage = failMessage + adoe.getMessage() + "\"";
                fail(failMessage);
            }
            // Now testing that adding 0 does not change the number
            result = testIntegers.get(i).plus(0);
            assertEquals(testIntegers.get(i), result);
        }
        /* And now to test that adding algebraic integers from two different 
           quadratic integer rings triggers AlgebraicDegreeOverflowException */
        for (int j = 0; j < totalTestIntegers - 1; j++) {
            try {
                result = testIntegers.get(j).plus(testIntegers.get(j + 1));
                failMessage = "Adding " + testIntegers.get(j).toASCIIString() + " to " + testIntegers.get(j + 1).toASCIIString() + " should not have resulted in " + result.toASCIIString() + " without triggering AlgebraicDegreeOverflowException.";
                fail(failMessage);
            } catch (AlgebraicDegreeOverflowException adoe) {
                System.out.println("Adding " + testIntegers.get(j).toASCIIString() + " to " + testIntegers.get(j + 1).toASCIIString() + " correctly triggered AlgebraicDegreeOverflowException (algebraic degree " + adoe.getNecessaryAlgebraicDegree() + " needed).");
            }
            /* However, if one of them is purely real, there should be a result, 
               even if it takes us to a different ring */
            failMessage = "Adding " + testNorms.get(j).toASCIIString() + " from " + testNorms.get(j).getRing().toASCIIString() + " to " + testIntegers.get(j + 1).toASCIIString() + " should not have caused";
            try {
                result = testNorms.get(j).plus(testIntegers.get(j + 1));
                System.out.println("Adding " + testNorms.get(j).toASCIIString() + " from " + testNorms.get(j).getRing().toASCIIString() + " to " + testIntegers.get(j + 1).toASCIIString() + " gives result " + result.toASCIIString());
            } catch (AlgebraicDegreeOverflowException adoe) {
                failMessage = failMessage + "AlgebraicDegreeOverflowException \"" + adoe.getMessage() + "\"";
                fail(failMessage);
            } catch (Exception e) {
                failMessage = failMessage + "Exception \"" + e.getMessage() + "\"";
                fail(failMessage);
            }
            failMessage = "Adding " + testNorms.get(j + 1).toASCIIString() + " from " + testNorms.get(j + 1).getRing().toASCIIString() + " to " + testIntegers.get(j).toASCIIString() + " should not have caused";
            try {
                result = testIntegers.get(j).plus(testNorms.get(j + 1));
                System.out.println("Adding " + testNorms.get(j + 1).toASCIIString() + " from " + testNorms.get(j + 1).getRing().toASCIIString() + " to " + testIntegers.get(j).toASCIIString() + " gives result " + result.toASCIIString());
            } catch (AlgebraicDegreeOverflowException adoe) {
                failMessage = failMessage + "AlgebraicDegreeOverflowException \"" + adoe.getMessage() + "\"";
                fail(failMessage);
            } catch (Exception e) {
                failMessage = failMessage + "Exception \"" + e.getMessage() + "\"";
                fail(failMessage);
            }
        }
    }

    /**
     * Test of minus method, of class ImaginaryQuadraticInteger.
     */
    @Test
    public void testMinus() {
        System.out.println("minus");
        ImaginaryQuadraticRing currRing;
        QuadraticInteger expResult, result, testMinuend, testSubtrahend;
        int currDenom;
        String failMessage;
        for (int iterDiscr = -1; iterDiscr > -200; iterDiscr--) {
            if (NumberTheoreticFunctionsCalculator.isSquareFree(iterDiscr)) {
                currRing = new ImaginaryQuadraticRing(iterDiscr);
                if (currRing.hasHalfIntegers()) {
                    currDenom = 2;
                } else {
                    currDenom = 1;
                }
                for (int v = -3; v < 48; v += 2) {
                    for (int w = -3; w < 48; w += 2) {
                        testMinuend = new ImaginaryQuadraticInteger(v, w, currRing, currDenom);
                        for (int x = -3; x < 48; x += 2) {
                            for (int y = -3; y < 48; y += 2) {
                                testSubtrahend = new ImaginaryQuadraticInteger(x, y, currRing, currDenom);
                                expResult = new ImaginaryQuadraticInteger(v - x, w - y, currRing, currDenom);
                                try {
                                    result = testMinuend.minus(testSubtrahend);
                                    assertEquals(expResult, result);
                                } catch (AlgebraicDegreeOverflowException adoe) {
                                    failMessage = "Subtracting two integers from the same ring should not have triggered AlgebraicDegreeOverflowException \"" + adoe.getMessage() + "\"";
                                    fail(failMessage);
                                }
                            }
                            // Now to test minus(int)
                            if (currRing.hasHalfIntegers()) {
                                expResult = new ImaginaryQuadraticInteger(v - 2 * x, w, currRing, 2);
                            } else {
                                expResult = new ImaginaryQuadraticInteger(v - x, w, currRing);
                            }
                            result = testMinuend.minus(x);
                            assertEquals(expResult, result);
                        }
                    }
                }
            }
        }
        for (int i = 0; i < totalTestIntegers; i++) {
            // Testing that subtracting itself gives 0 each time
            expResult = new ImaginaryQuadraticInteger(0, 0, testIntegers.get(i).getRing());
            try {
                result = testIntegers.get(i).minus(testIntegers.get(i));
                assertEquals(expResult, result);
            } catch (AlgebraicDegreeOverflowException adoe) {
                failMessage = "Subtracting test integer from itself should not have triggered AlgebraicDegreeOverflowException \"" + adoe.getMessage();
                fail(failMessage);
            }
            // Now testing that subtracting 0 does not change the number
            result = testIntegers.get(i).minus(0);
            assertEquals(testIntegers.get(i), result);
        }
        /* And now to test that subtracting algebraic integers from two 
           different quadratic integer rings triggers 
           AlgebraicDegreeOverflowException */
        for (int j = 0; j < totalTestIntegers - 1; j++) {
            try {
                result = testIntegers.get(j).minus(testIntegers.get(j + 1));
                failMessage = "Subtracting " + testIntegers.get(j + 1).toASCIIString() + " to " + testIntegers.get(j).toASCIIString() + " should not have resulted in " + result.toASCIIString() + " without triggering AlgebraicDegreeOverflowException.";
                fail(failMessage);
            } catch (AlgebraicDegreeOverflowException adoe) {
                System.out.println("Subtracting " + testIntegers.get(j + 1).toASCIIString() + " from " + testIntegers.get(j).toASCIIString() + " correctly triggered AlgebraicDegreeOverflowException (algebraic degree " + adoe.getNecessaryAlgebraicDegree() + " needed).");
            }
            /* However, if one of them is purely real, there should be some kind 
               of result */
            failMessage = "Subtracting " + testIntegers.get(j + 1).toASCIIString() + " from " + testNorms.get(j).toASCIIString() + " from " + testNorms.get(j).getRing().toASCIIString() + " should not have triggered";
            try {
                result = testNorms.get(j).minus(testIntegers.get(j + 1));
                System.out.println(testNorms.get(j).toASCIIString() + " from " + testNorms.get(j).getRing().toASCIIString() + " minus " + testIntegers.get(j + 1).toASCIIString() + " is " + result.toASCIIString());
            } catch (AlgebraicDegreeOverflowException adoe) {
                failMessage = failMessage + " AlgebraicDegreeOverflowException \"" + adoe.getMessage() + "\"";
                fail(failMessage);
            } catch (Exception e) {
                failMessage = failMessage + " Exception \"" + e.getMessage() + "\"";
                fail(failMessage);
            }
        }
    }

    /**
     * Test of times method, of class ImaginaryQuadraticInteger. This test 
     * includes multiplication of numbers from several imaginary quadratic 
     * rings, including tests of numbers from different rings to make sure 
     * {@link AlgebraicDegreeOverflowException} is thrown correctly. Of course 
     * testing that that exception itself works correctly falls to {@link 
     * AlgebraicDegreeOverflowExceptionTest}.
     */
    @Test
    public void testTimes() {
        System.out.println("times");
        ImaginaryQuadraticRing currRing;
        QuadraticInteger expResult, result, testMultiplicandA, testMultiplicandB;
        int currDenom;
        String failMessage;
        for (int iterDiscr = -1; iterDiscr > -200; iterDiscr--) {
            if (NumberTheoreticFunctionsCalculator.isSquareFree(iterDiscr)) {
                currRing = new ImaginaryQuadraticRing(iterDiscr);
                if (currRing.hasHalfIntegers()) {
                    currDenom = 2;
                } else {
                    currDenom = 1;
                }
                for (int v = -3; v < 48; v += 2) {
                    for (int w = -3; w < 48; w += 2) {
                        testMultiplicandA = new ImaginaryQuadraticInteger(v, w, currRing, currDenom);
                        for (int x = -3; x < 48; x += 2) {
                            for (int y = -3; y < 48; y += 2) {
                                testMultiplicandB = new ImaginaryQuadraticInteger(x, y, currRing, currDenom);
                                if (currRing.hasHalfIntegers()) {
                                    expResult = new ImaginaryQuadraticInteger((v * x + w * y * iterDiscr)/2, (v * y + w * x)/2, currRing, currDenom);
                                } else {
                                    expResult = new ImaginaryQuadraticInteger(v * x + w * y * iterDiscr, v * y + w * x, currRing, currDenom);
                                }
                                try {
                                    result = testMultiplicandA.times(testMultiplicandB);
                                    assertEquals(expResult, result);
                                } catch (AlgebraicDegreeOverflowException adoe) {
                                    failMessage = "Multiplying two integers from the same ring should not have triggered AlgebraicDegreeOverflowException \"" + adoe.getMessage() + "\"";
                                    fail(failMessage);
                                }
                            }
                            // Now to test times(int)
                            expResult = new ImaginaryQuadraticInteger(v * x, w * x, currRing, currDenom);
                            result = testMultiplicandA.times(x);
                            assertEquals(expResult, result);
                        }
                    }
                }
            }
        }
        // Complex integer times its conjugate should match its norm
        for (int i = 0; i < totalTestIntegers; i++) {
            try {
                result = testIntegers.get(i).times(testConjugates.get(i));
                assertEquals(testNorms.get(i), result);
            } catch (AlgebraicDegreeOverflowException adoe) {
                failMessage = "Multiplying an integer by its conjugate should not have triggered AlgebraicDegreeOverflowException \"" + adoe.getMessage();
                fail(failMessage);
            }
        }
        /* And now to test that multiplying algebraic integers from two 
           different quadratic integer rings triggers 
           AlgebraicDegreeOverflowException */
        for (int j = 0; j < totalTestIntegers - 1; j++) {
            try {
                result = testIntegers.get(j).times(testIntegers.get(j + 1));
                failMessage = "Multiplying " + testIntegers.get(j).toASCIIString() + " by " + testIntegers.get(j + 1).toASCIIString() + " should not have resulted in " + result.toASCIIString() + " without triggering AlgebraicDegreeOverflowException.";
                fail(failMessage);
            } catch (AlgebraicDegreeOverflowException adoe) {
                failMessage = "Necessary degree should be 4, not " + adoe.getNecessaryAlgebraicDegree() + ", for multiplying " + testIntegers.get(j).toASCIIString() + " by " + testIntegers.get(j + 1).toASCIIString() + ".";
                assertEquals(failMessage, 4, adoe.getNecessaryAlgebraicDegree());
                System.out.println("Multiplying " + testIntegers.get(j).toASCIIString() + " by " + testIntegers.get(j + 1).toASCIIString() + " correctly triggered AlgebraicDegreeOverflowException (algebraic degree " + adoe.getNecessaryAlgebraicDegree() + " needed).");
            }
            /* However, if one of them is purely real, there should be a result, 
               even if it takes us to a different ring */
            failMessage = "Multiplying " + testNorms.get(j).toASCIIString() + " from " + testNorms.get(j).getRing().toASCIIString() + " by " + testIntegers.get(j + 1).toASCIIString() + " should not have caused";
            try {
                result = testNorms.get(j).times(testIntegers.get(j + 1));
                System.out.println("Multiplying " + testNorms.get(j).toASCIIString() + " from " + testNorms.get(j).getRing().toASCIIString() + " by " + testIntegers.get(j + 1).toASCIIString() + " gives result " + result.toASCIIString());
            } catch (AlgebraicDegreeOverflowException adoe) {
                failMessage = failMessage + " AlgebraicDegreeOverflowException \"" + adoe.getMessage() + "\"";
                fail(failMessage);
            } catch (Exception e) {
                failMessage = failMessage + " Exception \"" + e.getMessage() + "\"";
                fail(failMessage);
            }
            failMessage = "Multiplying " + testNorms.get(j + 1).toASCIIString() + " from " + testNorms.get(j + 1).getRing().toASCIIString() + " by " + testIntegers.get(j).toASCIIString() + " should not have caused";
            try {
                result = testIntegers.get(j).times(testNorms.get(j + 1));
                System.out.println("Multiplying " + testNorms.get(j + 1).toASCIIString() + " from " + testNorms.get(j + 1).getRing().toASCIIString() + " by " + testIntegers.get(j).toASCIIString() + " gives result " + result.toASCIIString());
            } catch (AlgebraicDegreeOverflowException adoe) {
                failMessage = failMessage + " AlgebraicDegreeOverflowException \"" + adoe.getMessage() + "\"";
                fail(failMessage);
            } catch (Exception e) {
                failMessage = failMessage + " Exception \"" + e.getMessage() + "\"";
                fail(failMessage);
            }
        }
    }

    /**
     * Test of divides method, of class ImaginaryQuadraticInteger. This test 
     * multiplies several algebraic integers in the rings <b>Z</b>[<i>i</i>] to 
     * <b>Z</b>[&radic;-199], then divides to get back the first number. So if 
     * the test of the times method fails, the result of this test is 
     * meaningless. In regards to division by zero, this test will pass if 
     * either {@link IllegalArgumentException} or {@link ArithmeticException} is 
     * thrown. Any other exception will fail the test, and that includes the 
     * {@link NotDivisibleException}. Not throwing any exception at all for 
     * division by zero will also fail the test.
     */
    @Test
    public void testDivides() {
        System.out.println("divides(ImaginaryQuadraticInteger)");
        ImaginaryQuadraticRing currRing;
        QuadraticInteger expResult, result, testQuotient, testDivisor, testDividend;
        int currDenom;
        String failMessage;
        for (int iterDiscr = -1; iterDiscr > -100; iterDiscr--) {
            if (NumberTheoreticFunctionsCalculator.isSquareFree(iterDiscr)) {
                currRing = new ImaginaryQuadraticRing(iterDiscr);
                if (currRing.hasHalfIntegers()) {
                    currDenom = 2;
                } else {
                    currDenom = 1;
                }
                for (int v = -3; v < 48; v += 2) {
                    for (int w = 3; w < 54; w += 2) {
                        testQuotient = new ImaginaryQuadraticInteger(v, w, currRing, currDenom);
                        for (int x = -3; x < 48; x += 2) {
                            for (int y = 3; y < 54; y += 2) {
                                testDivisor = new ImaginaryQuadraticInteger(x, y, currRing, currDenom);
                                try {
                                    testDividend = testQuotient.times(testDivisor);
                                } catch (AlgebraicDegreeOverflowException adoe) {
                                    testDividend = zeroIQI; // This is just to avoid "variable result might not have been initialized" error
                                    failMessage = "Check results of times() test for incorrect triggering of AlgebraicDegreeOverflowException \"" + adoe.getMessage() + "\"";
                                    fail(failMessage);
                                }
                                try {
                                    result = testDividend.divides(testDivisor);
                                    assertEquals(testQuotient, result);
                                } catch (AlgebraicDegreeOverflowException adoe) {
                                    failMessage = "Dividing one integer by another from the same ring should not have triggered AlgebraicDegreeOverflowException \"" + adoe.getMessage() + "\"";
                                    fail(failMessage);
                                } catch (NotDivisibleException nde) {
                                    failMessage = "Dividing " + testDividend.toASCIIString() + " by " + testDivisor.toASCIIString() + " should not have triggered NotDivisibleException \"" + nde.getMessage() + "\"";
                                    fail(failMessage);
                                }
                                
                            }
                            // Now to test divides(int)
                            testDividend = new ImaginaryQuadraticInteger(v * x, w * x, currRing, currDenom);
                            expResult = new ImaginaryQuadraticInteger(v, w, currRing, currDenom);
                            try {
                                result = testDividend.divides(x);
                                assertEquals(expResult, result);
                            } catch (NotDivisibleException nde) {
                                failMessage = "Dividing " + testDividend.toASCIIString() + " by " + x + " should not have triggered NotDivisibleException\"" + nde.getMessage() + "\"";
                                fail(failMessage);
                            }
                            
                        }
                    }
                }
            }
        }
        /* Now to test dividing a purely real integer held in an 
           ImaginaryQuadraticInteger object divided by a purely real integer in 
           an int */
        System.out.println("divides(int)");
        int testDivRealPartMult;
        for (int iterDiscrOQ = -11; iterDiscrOQ > -84; iterDiscrOQ -= 8) {
            if (NumberTheoreticFunctionsCalculator.isSquareFree(iterDiscrOQ)) {
                currRing = new ImaginaryQuadraticRing(iterDiscrOQ);
                testDivRealPartMult = (-iterDiscrOQ + 1)/4;
                testDividend = new ImaginaryQuadraticInteger(testDivRealPartMult, 0, currRing);
                try {
                    result = testDividend.divides(2);
                    failMessage = "Trying to divide " + testDividend.toString() + " by 2 in " + currRing.toString() + " should have triggered NotDivisibleException, not given result " + result.toString();
                    fail(failMessage);
                } catch (NotDivisibleException nde) {
                    System.out.println("Trying to divide " + testDividend.toASCIIString() + " by 2 in " + currRing.toASCIIString() + " correctly triggered NotDivisibleException \"" + nde.getMessage() + "\"");
                } catch (Exception e) {
                    System.out.println("Encountered this exception: " + e.getClass().getName() + " \"" + e.getMessage() + "\"");
                    failMessage = "Trying to divide " + testDividend.toString() + " by 2 in " + currRing.toString() + " triggered the wrong exception.";
                    fail(failMessage);
                }
            }
        }
        for (int i = 0; i < totalTestIntegers; i++) {
            try {
                result = testNorms.get(i).divides(testConjugates.get(i));
                System.out.println(testNorms.get(i).toASCIIString() + " divided by " + testConjugates.get(i).toASCIIString() + " is " + result.toASCIIString());
                assertEquals(testIntegers.get(i), result);
            } catch (AlgebraicDegreeOverflowException adoe) {
                failMessage = "AlgebraicDegreeOverflowException should not have occurred \"" + adoe.getMessage() + "\"";
                fail(failMessage);
            } catch (NotDivisibleException nde) {
                System.out.println(testNorms.get(i).toASCIIString() + " divided by " + testConjugates.get(i).toASCIIString() + " is (" + nde.getFractNumers()[0] + " + " + nde.getFractDenoms()[1] + "sqrt(" + ((QuadraticRing) nde.getCausingRing()).getRadicand() + "))/" + nde.getFractDenoms()[0]);
                failMessage = "NotDivisibleException should not have occurred in dividing a norm by a conjugate.";
                fail(failMessage);
            }
            try {
                result = testNorms.get(i).divides(testIntegers.get(i));
                System.out.println(testNorms.get(i).toASCIIString() + " divided by " + testIntegers.get(i).toASCIIString() + " is " + result.toASCIIString());
                assertEquals(testConjugates.get(i), result);
            } catch (AlgebraicDegreeOverflowException adoe) {
                failMessage = "AlgebraicDegreeOverflowException should not have occurred \"" + adoe.getMessage() + "\"";
                fail(failMessage);
            } catch (NotDivisibleException nde) {
                System.out.println(testNorms.get(i).toASCIIString() + " divided by " + testIntegers.get(i).toASCIIString() + " is (" + nde.getFractNumers()[0] + " + " + nde.getFractDenoms()[1] + "sqrt(" + ((QuadraticRing) nde.getCausingRing()).getRadicand() + "))/" + nde.getFractDenoms()[0]);
                failMessage = "NotDivisibleException should not have occurred in dividing a norm by a conjugate.";
                fail(failMessage);
            }
            // Check to make sure division by zero causes a suitable exception
            try {
                result = testIntegers.get(i).divides(zeroIQI);
                failMessage = "Dividing " + testIntegers.get(i).toASCIIString() + " by 0 + 0i should have caused an exception, not given result " + result.toASCIIString();
                fail(failMessage);
            } catch (AlgebraicDegreeOverflowException adoe) {
                failMessage = "AlgebraicDegreeOverflowException is the wrong exception to throw for division by 0 + 0i \"" + adoe.getMessage() + "\"";
                fail(failMessage);
            } catch (NotDivisibleException nde) {
                failMessage = "NotDivisibleException is the wrong exception to throw for division by 0 + 0i \"" + nde.getMessage() + "\"";
                fail(failMessage);
            } catch (IllegalArgumentException iae) {
                System.out.println("IllegalArgumentException correctly triggered upon attempt to divide by 0 + 0i \"" + iae.getMessage() + "\"");
            } catch (ArithmeticException ae) {
                System.out.println("ArithmeticException correctly triggered upon attempt to divide by 0 + 0i \"" + ae.getMessage() + "\"");
            } catch (Exception e) {
                failMessage = "Wrong exception thrown for attempt to divide by 0 + 0i. " + e.getMessage();
                fail(failMessage);
            }
            try {
                result = testIntegers.get(i).divides(0);
                failMessage = "Dividing " + testIntegers.get(i).toASCIIString() + " by 0 should have caused an exception, not given result " + result.toASCIIString();
                fail(failMessage);
            } catch (NotDivisibleException nde) {
                failMessage = "NotDivisibleException is the wrong exception to throw for division by 0 \"" + nde.getMessage() + "\"";
                fail(failMessage);
            } catch (IllegalArgumentException iae) {
                System.out.println("IllegalArgumentException correctly triggered upon attempt to divide by 0 \"" + iae.getMessage() + "\"");
            } catch (ArithmeticException ae) {
                System.out.println("ArithmeticException correctly triggered upon attempt to divide by 0. \"" + ae.getMessage() + "\"");
            } catch (Exception e) {
                failMessage = "Wrong exception thrown for attempt to divide by 0. " + e.getMessage();
                fail(failMessage);
            }
        }
        /* Check that dividing an imaginary quadratic integer from one ring by a 
           purely real integer from another ring does give the same result as if 
           the purely real integer was presented as being from the same ring. */
        testDividend = new ImaginaryQuadraticInteger(3, 1, RING_EISENSTEIN);
        testDivisor = new ImaginaryQuadraticInteger(2, 0, RING_GAUSSIAN);
        expResult = new ImaginaryQuadraticInteger(3, 1, RING_EISENSTEIN, 2);
        failMessage = "Trying to divide " + testDividend.toASCIIString() + " by " + testDivisor.toASCIIString() + " from " + testDivisor.getRing().toASCIIString() + " should not have triggered";
        try {
            result = testDividend.divides(testDivisor);
            assertEquals(expResult, result);
        } catch (NotDivisibleException nde) {
            failMessage = failMessage + " NotDivisibleException \"" + nde.getMessage() + "\"";
            fail(failMessage);
        } catch (AlgebraicDegreeOverflowException adoe) {
            failMessage = failMessage + " AlgebraicDegreeOverflowException \"" + adoe.getMessage() + "\"";
            fail(failMessage);
        } catch (Exception e) {
            failMessage = failMessage + e.getClass().getName() + "\"" + e.getMessage() + "\"";
            fail(failMessage);
        }
        /* And now to test that dividing an algebraic integer from one imaginary 
           quadratic ring by an algebraic integer from another imaginary 
           quadratic ring triggers AlgebraicDegreeOverflowException */
        QuadraticInteger temp;
        for (int j = 0; j < totalTestIntegers - 1; j++) {
            failMessage = "Dividing " + testIntegers.get(j).toASCIIString() + " by " + testIntegers.get(j + 1).toASCIIString() + " should not have";
            try {
                result = testIntegers.get(j).divides(testIntegers.get(j + 1));
                failMessage = failMessage + " resulted in " + result.toASCIIString() + " without triggering AlgebraicDegreeOverflowException.";
                fail(failMessage);
            } catch (AlgebraicDegreeOverflowException adoe) {
                failMessage = "Necessary degree should be 4, not " + adoe.getNecessaryAlgebraicDegree() + ", for multiplying " + testIntegers.get(j).toASCIIString() + " by " + testIntegers.get(j + 1).toASCIIString() + ".";
                assertEquals(failMessage, 4, adoe.getNecessaryAlgebraicDegree());
                System.out.println("Dividing " + testIntegers.get(j).toASCIIString() + " by " + testIntegers.get(j + 1).toASCIIString() + " correctly triggered AlgebraicDegreeOverflowException (algebraic degree " + adoe.getNecessaryAlgebraicDegree() + " needed).");
            } catch (NotDivisibleException nde) {
                failMessage = failMessage + " triggered NotDivisibleException \"" + nde.getMessage() + "\"";
                fail(failMessage);
            }
            /* However, if the divisor is purely real, there should be a result, 
               even if it takes us to a different ring */
            temp = testIntegers.get(j + 1).times(testNorms.get(j));
            failMessage = "Dividing " + temp.toASCIIString() + " from " + temp.getRing().toASCIIString() + " by " + testNorms.get(j).toASCIIString() + " from " + testNorms.get(j).getRing().toASCIIString() + " should not have caused";
            try {
                result = temp.divides(testNorms.get(j));
                System.out.println("Dividing " + temp.toASCIIString() + " from " + temp.getRing().toASCIIString() + " by " + testNorms.get(j).toASCIIString() + " from " + testNorms.get(j).getRing().toASCIIString() + " gives result " + result.toASCIIString());
            } catch (AlgebraicDegreeOverflowException adoe) {
                failMessage = failMessage + " AlgebraicDegreeOverflowException \"" + adoe.getMessage() + "\"";
                fail(failMessage);
            } catch (NotDivisibleException nde) {
                failMessage = failMessage + " NotDivisibleException \"" + nde.getMessage() + "\"";
                fail(failMessage);
            } catch (Exception e) {
                failMessage = failMessage + " Exception \"" + e.getMessage() + "\"";
                fail(failMessage);
            }
        }
        /* And lastly, to test that dividing a purely imaginary number from one 
           domain is divided by a purely imaginary number from another domain 
           triggers UnsupportedNumberDomainException. It will be enough to check 
           sqrt(-10)/sqrt(-2), which would give sqrt(5) only if there was a way 
           for this to give a real quadratic integer. */
        testDividend = new ImaginaryQuadraticInteger(0, 1, new ImaginaryQuadraticRing(-10));
        testDivisor = new ImaginaryQuadraticInteger(0, 1, RING_ZI2);
        failMessage = "Dividing " + testDividend.toASCIIString() + " by " + testDivisor.toASCIIString() + " should not have";
        try {
            result = testDividend.divides(testDivisor);
            failMessage = failMessage + " resulted in " + result.toASCIIString() + " without triggering some sort of exception.";
            fail(failMessage);
        } catch (UnsupportedNumberDomainException unde) {
            double realNumericApprox = Math.sqrt(5);
            System.out.println("Dividing " + testDividend.toASCIIString() + " by " + testDivisor.toASCIIString() + " correctly triggered UnsupportedNumberDomainException \"" + unde.getMessage() + "\"");
            System.out.println("This is perhaps the best solution if the source package lacks a way to represent the real number sqrt(5), approximately " + realNumericApprox + "...");
        } catch (AlgebraicDegreeOverflowException adoe) {
            failMessage = failMessage + " triggered AlgebraicDegreeOverflowException \"" + adoe.getMessage() + "\"";
            fail(failMessage);
        } catch(NotDivisibleException nde) {
            failMessage = failMessage + " triggered NotDivisibleException \"" + nde.getMessage() + "\"";
            fail(failMessage);
        } catch (Exception e) {
            failMessage = failMessage + " caused" + e.getClass().getName() + "\"" + e.getMessage() + "\"";
            fail(failMessage);
        }
    }
    
    /**
     * Test of the times, norm and abs methods, simultaneously, of class 
     * ImaginaryQuadraticInteger. This test also does a little bit with 
 getRealPartNumeric and getImagPartNumeric. So if the 
 independent tests for any of those are failing, the result of this test 
 is meaningless.
     */
    @Test
    public void testSimultTimesAndNormAndAbs() {
        System.out.println("times and norm and abs, simultaneously");
        QuadraticInteger gauInt = new ImaginaryQuadraticInteger(0, 0, RING_GAUSSIAN);
        QuadraticInteger eisenInt = new ImaginaryQuadraticInteger(0, 0, RING_EISENSTEIN);
        long normResult, currSquare;
        double absResult;
        for (int n = 1; n < 25; n++) {
            gauInt = gauInt.plus(1); // Purely real for now
            eisenInt = eisenInt.plus(1); // Also purely real for now
            currSquare = n * n;
            normResult = gauInt.norm(); // Concentrating on the Gaussian integers for now
            assertEquals(currSquare, normResult);
            absResult = gauInt.abs();
            assertEquals(n, absResult, ImaginaryQuadraticRingTest.TEST_DELTA);
            assertEquals(absResult, Math.abs(gauInt.getRealPartNumeric()), ImaginaryQuadraticRingTest.TEST_DELTA);
            gauInt = gauInt.times(IMAG_UNIT_I); // n * i
            normResult = gauInt.norm();
            assertEquals(currSquare, normResult);
            absResult = gauInt.abs();
            assertEquals(n, absResult, ImaginaryQuadraticRingTest.TEST_DELTA);
            assertEquals(absResult, Math.abs(gauInt.getImagPartNumeric()), ImaginaryQuadraticRingTest.TEST_DELTA);
            normResult = gauInt.norm();
            assertEquals(currSquare, normResult);
            gauInt = gauInt.times(IMAG_UNIT_I); // -n
            absResult = gauInt.abs();
            assertEquals(n, absResult, ImaginaryQuadraticRingTest.TEST_DELTA);
            assertEquals(absResult, Math.abs(gauInt.getRealPartNumeric()), ImaginaryQuadraticRingTest.TEST_DELTA);
            normResult = gauInt.norm();
            assertEquals(currSquare, normResult);
            gauInt = gauInt.times(IMAG_UNIT_I); // -n * i
            absResult = gauInt.abs();
            assertEquals(n, absResult, ImaginaryQuadraticRingTest.TEST_DELTA);
            assertEquals(absResult, Math.abs(gauInt.getImagPartNumeric()), ImaginaryQuadraticRingTest.TEST_DELTA);
            normResult = gauInt.norm();
            assertEquals(currSquare, normResult);
            gauInt = gauInt.times(IMAG_UNIT_I); // Back to n
            normResult = gauInt.norm();
            assertEquals(currSquare, normResult);
            absResult = gauInt.abs();
            assertEquals(n, absResult, ImaginaryQuadraticRingTest.TEST_DELTA);
            // And then the Eisenstein integers
            normResult = eisenInt.norm();
            assertEquals(currSquare, normResult);
            absResult = eisenInt.abs();
            assertEquals(n, absResult, ImaginaryQuadraticRingTest.TEST_DELTA);
            eisenInt = eisenInt.times(COMPLEX_CUBIC_ROOT_OF_UNITY); // n * omega
            normResult = eisenInt.norm();
            assertEquals(currSquare, normResult);
            absResult = eisenInt.abs();
            assertEquals(n, absResult, ImaginaryQuadraticRingTest.TEST_DELTA);
            eisenInt = eisenInt.times(COMPLEX_CUBIC_ROOT_OF_UNITY); // n * omega^2
            normResult = eisenInt.norm();
            assertEquals(currSquare, normResult);
            absResult = eisenInt.abs();
            assertEquals(n, absResult, ImaginaryQuadraticRingTest.TEST_DELTA);
            eisenInt = eisenInt.times(COMPLEX_CUBIC_ROOT_OF_UNITY);
            eisenInt = eisenInt.times(-1); // -n
            normResult = eisenInt.norm();
            assertEquals(currSquare, normResult);
            absResult = eisenInt.abs();
            assertEquals(n, absResult, ImaginaryQuadraticRingTest.TEST_DELTA);
            eisenInt = eisenInt.times(COMPLEX_CUBIC_ROOT_OF_UNITY); // -n * omega
            normResult = eisenInt.norm();
            assertEquals(currSquare, normResult);
            absResult = eisenInt.abs();
            assertEquals(n, absResult, ImaginaryQuadraticRingTest.TEST_DELTA);
            eisenInt = eisenInt.times(COMPLEX_CUBIC_ROOT_OF_UNITY); // -n * omega^2
            normResult = eisenInt.norm();
            assertEquals(currSquare, normResult);
            absResult = eisenInt.abs();
            assertEquals(n, absResult, ImaginaryQuadraticRingTest.TEST_DELTA);
            eisenInt = eisenInt.times(COMPLEX_CUBIC_ROOT_OF_UNITY);
            eisenInt = eisenInt.times(-1); // Back to n
            normResult = eisenInt.norm();
            assertEquals(currSquare, normResult);
            absResult = eisenInt.abs();
            assertEquals(n, absResult, ImaginaryQuadraticRingTest.TEST_DELTA);
        }
    }

    /**
     * Test of ImaginaryQuadraticInteger class constructor. The main thing we're 
     * testing here is that an invalid argument triggers an 
     * {@link IllegalArgumentException}.
     */
    @Test
    public void testConstructor() {
        System.out.println("ImaginaryQuadraticInteger (constructor)");
        ImaginaryQuadraticInteger quadrInt = new ImaginaryQuadraticInteger(1, 3, RING_ZI2, 1); // This should work fine
        System.out.println("Created " + quadrInt.toASCIIString() + " without problem.");
        quadrInt = new ImaginaryQuadraticInteger(7, 5, RING_EISENSTEIN, 2); // This should also work fine
        System.out.println("Created " + quadrInt.toASCIIString() + " without problem.");
        quadrInt = new ImaginaryQuadraticInteger(6, 4, RING_GAUSSIAN, -2); // This should also work, right?
        System.out.println("Created " + quadrInt.toASCIIString() + " without problem.");
        // Test 3-parameter constructor
        quadrInt = new ImaginaryQuadraticInteger(5, 3, RING_OQI7);
        System.out.println("Created " + quadrInt.toASCIIString() + " without problem.");
        ImaginaryQuadraticInteger comparisonInt = new ImaginaryQuadraticInteger(5, 3, RING_OQI7, 1);
        assertEquals(quadrInt, comparisonInt); // It should be the case that 5 + 3sqrt(-7) = 5 + 3sqrt(-7)
        comparisonInt = new ImaginaryQuadraticInteger(5, 3, RING_OQI7, 2);
        assertNotEquals(quadrInt, comparisonInt); // 5 + 3sqrt(-7) = 5/2 + 3sqrt(-7)/2 would be wrong
        try {
            quadrInt = new ImaginaryQuadraticInteger(3, 1, ringRandom, 4);
            System.out.println("Somehow created " + quadrInt.toASCIIString() + " without problem.");
            fail("Attempt to create ImaginaryQuadraticInteger with denominator 4 should have caused an IllegalArgumentException.");
        } catch (IllegalArgumentException iae) {
            System.out.println("Attempt to use denominator 4 correctly triggered IllegalArgumentException \"" + iae.getMessage() + "\"");
        }
        try {
            quadrInt = new ImaginaryQuadraticInteger(3, 2, RING_EISENSTEIN, 2);
            System.out.println("Somehow created " + quadrInt.toASCIIString() + " without problem.");
            fail("Attempt to create ImaginaryQuadraticInteger with mismatched parities of a and b should have caused an IllegalArgumentException.");
        } catch (IllegalArgumentException iae) {
            System.out.println("Attempt to use mismatched parities correctly triggered IllegalArgumentException \"" + iae.getMessage() + "\"");
        }
    }    
    
}